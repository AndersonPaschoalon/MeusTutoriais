# **Capítulo 16 — Estudos de Caso em Plataformas Reais (Janela 1/2)**

Focaremos aqui nas duas primeiras plataformas: Arduino e Raspberry Pi.

---

## **16.1 Arduino: Bare-Metal e Temporização**

Arduino, apesar de amplamente utilizado em projetos simples, é uma excelente porta de entrada para conceitos fundamentais de sistemas embarcados, pois expõe diretamente o microcontrolador AVR (por exemplo, o ATmega328P no Arduino Uno).
Aqui veremos **bare-metal**, timers, GPIO, interrupções e PWM, mas com uma abordagem técnica e profissional — acima do nível “Arduino IDE”.

---

### **16.1.1 Arquitetura relevante do ATmega328P**

#### **Componentes essenciais**

* CPU AVR de 8 bits com pipeline simples
* 32 registradores de propósito geral (R0–R31)
* Flash 32 KB (programa)
* SRAM 2 KB
* EEPROM 1 KB
* Timers:

  * Timer0 — 8 bits (base do `millis()` no Arduino)
  * Timer1 — 16 bits (ideal para PWM preciso e temporização crítica)
  * Timer2 — 8 bits
* Interrupções: INT0/INT1, timers, UART, SPI, TWI
* GPIO: portas B, C, D

---

### **16.1.2 Acesso bare-metal a GPIO**

Quando removemos o framework Arduino, controlar um pino vira manipular registradores.

Exemplo: piscar o LED no PB5 (digital 13), usando *somente registradores AVR*:

```c
// Código C bare-metal para ATmega328P
#include <avr/io.h>
#include <util/delay.h>

int main(void) {
    DDRB |= (1 << PB5);      // PB5 como saída

    while (1) {
        PORTB ^= (1 << PB5); // Toggle
        _delay_ms(500);
    }
}
```

Comentários importantes:

* O delay de util/delay.h usa *busy loop* baseado em F_CPU.
* O acesso direto a registradores está mais próximo do “hardware real” que o Arduino IDE.
* Este exemplo já ilustra o modelo de programação declarativo do AVR: cada porta tem DDRx (direção), PORTx (escrita) e PINx (leitura).

---

### **16.1.3 Temporização com Timer1 (modo CTC)**

Um temporizador é fundamental em sistemas embarcados.
Aqui configuramos o Timer1 para gerar interrupções periódicas de 1 ms.

```c
#include <avr/io.h>
#include <avr/interrupt.h>

ISR(TIMER1_COMPA_vect) {
    PORTB ^= (1 << PB5); // Inverter LED a cada interrupção
}

int main(void) {
    DDRB |= (1 << PB5);

    TCCR1B |= (1 << WGM12);         // Modo CTC
    OCR1A = 15999;                  // 1ms @ 16 MHz, prescaler 1
    TCCR1B |= (1 << CS10);          // prescaler = 1

    TIMSK1 |= (1 << OCIE1A);        // Habilita interrupção
    sei();                          // Habilita interrupções globais

    while (1) {
        // loop vazio -> CPU livre para outras tarefas
    }
}
```

Este exemplo já comunica três lições-chave:

1. **Gerar periodicidade estável (sem drift)** → ideal para aquisição de dados
2. **Interrupção limpa e rápida** → boa prática
3. **Separação entre temporização e lógica** → favorece manutenção

---

### **16.1.4 Observações práticas**

* A forma correta de produzir temporização robusta é usar *timers*, não `delay()`.
* Códigos críticos devem evitar Arduino Framework;
* Mesmo em Arduino é possível:

  * rodar FreeRTOS,
  * acessar registradores,
  * manipular clock,
  * usar interrupções avançadas.

Arduino é simples mas se comporta como **qualquer microcontrolador real** quando programado bare-metal.

---

---

## **16.2 Raspberry Pi: Linux Embarcado e Drivers no Espaço do Usuário**

Raspberry Pi é muito mais do que Arduino.
Aqui você não tem apenas um microcontrolador — você tem um **SoC ARM com Linux completo**, GPU, MMU, scheduler, processos e IPC.
Isto nos coloca em um cenário híbrido entre “sistemas embarcados” e “sistemas operacionais”.

---

### **16.2.1 Arquitetura geral**

#### **Hardware (Pi 3/4 típicos)**

* ARM Cortex-A53/A72 (quad ou octa-core)
* MMU + caches L1/L2
* GPIO controlados pelo bloco “Broadcom GPIO”
* periféricos mapeados em memória (MMIO)

#### **Software**

* Kernel Linux
* Device Tree
* Drivers no kernel
* Drivers em espaço do usuário (via sysfs, mmap, ioctl)
* Bibliotecas específicas: wiringPi, pigpio, RPi.GPIO

---

### **16.2.2 Acesso a GPIO via sysfs (modelo clássico)**

Apesar de sysfs GPIO estar depreciado nas versões novas, ele ainda é extremamente instrutivo para entender drivers de usuário.

Exemplo para exportar o GPIO 17 e piscar:

```bash
echo 17 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio17/direction

while true; do
    echo 1 > /sys/class/gpio/gpio17/value
    sleep 1
    echo 0 > /sys/class/gpio/gpio17/value
    sleep 1
done
```

Isto mostra imediatamente:

* driver do kernel expõe interface no filesystem
* aplicações podem manipular GPIO sem privilégios especiais
* controle é relativamente lento (por estar no espaço do usuário)

---

### **16.2.3 Acesso rápido via *memory mapping* (mmap)**

Para operações de tempo real suave (por ex., geração de PWM por software), é necessário ir além do sysfs.
Podemos mapear a região de registradores do SoC e escrever diretamente.

Exemplo minimalista em C (adaptado do modelo clássico do Linux para ARM):

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>

#define GPIO_BASE 0x3F200000  // para Raspberry Pi 3
#define BLOCK_SIZE 4096

volatile unsigned int *gpio;

int main() {
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    gpio = (unsigned int*) mmap(NULL, BLOCK_SIZE, PROT_READ | PROT_WRITE,
                                MAP_SHARED, fd, GPIO_BASE);

    // Configurar GPIO17 como saída
    gpio[1] &= ~(7 << 21);     // limpar bits (FSEL1: bits 21-23)
    gpio[1] |=  (1 << 21);     // setar como output

    while (1) {
        gpio[7] = 1 << 17;     // GPSET0
        usleep(500000);
        gpio[10] = 1 << 17;    // GPCLR0
        usleep(500000);
    }
}
```

Este exemplo é muito próximo ao **bare-metal**, mas ainda **dentro de Linux**.

---

### **16.2.4 Temporização em Linux embarcado**

#### **Lições fundamentais**

* Linux **não** é determinístico
* jitter de 50–500 μs é comum
* para hard real-time → usar **PREEMPT_RT** ou microcontrolador externo

Ainda assim, é possível atingir:

* soft real-time
* controle de eventos
* telemetria
* automação
* IoT gateway

---

### **16.2.5 Drivers no espaço do usuário via `ioctl`**

Um padrão amplamente usado é criar um driver mínimo no kernel e expor uma interface para o usuário:

Exemplo de chamada típica:

```c
int fd = open("/dev/mymotor", O_RDWR);
ioctl(fd, SET_SPEED, 80);
```

Este modelo é importante pois:

* separa a lógica sensível no kernel
* deixa a aplicação limpa no espaço de usuário
* aumenta segurança e desempenho

---

### **16.2.6 Device Tree Overlay**

Para habilitar periféricos (UARTs extras, SPI, I2C etc.), usamos o Device Tree:

Exemplo para habilitar SPI:

```bash
sudo dtoverlay spi0-1cs
```

Isso reflete um conceito central em sistemas embarcados modernos:

> Hardware é descrito em uma árvore, não em código C;
> o kernel interpreta essa descrição para montar os drivers.

---

### **16.2.7 Considerações práticas para projetos embarcados com Raspberry Pi**

* Nunca confie em temporização precisa por software
* Prefira DMA e periféricos de hardware
* Arquiteturas híbridas (Pi + MCU via UART/I2C/SPI) são superiores para sistemas de controle
* Cuidado com corrupção do SD
* Monitorar temperatura e voltagem
* Usar systemd + watchdog do kernel para robustez
* Evitar Python em tarefas sensíveis (latência e GC podem causar jitter)


## **16.3 PlayStation 1: Arquitetura MIPS, BIOS e DMA na prática (Parte 1/2)**

O PlayStation 1 (PSX ou PS1) é uma plataforma fascinante porque combina:

* **Hardware simples** o bastante para entendermos profundamente
* **Complexidade suficiente** para representar um sistema completo
* **Documentação disponível** (não oficial, mas excelente)
* **Ferramentas modernas** para compilar e rodar código homebrew

É um ambiente ideal para estudar:

> sistemas embarcados, organização de memória, CPU pipelines, DMA, GPUs primitivas e organização de BIOS.

---

## **16.3.1 Arquitetura geral**

#### **Componentes principais do PS1**

* **CPU**: MIPS R3000A (R3051A), 32 bits, clock ~33.8688 MHz
* **Coprocessadores**:

  * **COP0** – System control (TLB, exceções, registradores privilegiados)
  * **COP2** – GTE (Geometry Transformation Engine)
* **GPU** — rasterização 2D baseada em primitivas (triângulos, sprites, quadrados)
* **SPU** — processador de áudio (ADPCM), 512 KB de memória própria
* **CD-ROM controller** — interface de armazenamento
* **DMA controller** — 7 canais
* **Memória**:

  * RAM principal: **2 MB**
  * VRAM: **1 MB**
  * SPU RAM: **512 KB**
  * BIOS ROM: **512 KB**

---

#### **Mapa de memória simplificado**

```
0x0000_0000 – 0x001F_FFFF   RAM (KUSEG)
0x1F00_0000 – 0x1F7F_FFFF   Memory-mapped I/O
0x1FC0_0000 – 0x1FC7_FFFF   BIOS ROM
0x8000_0000 – 0x801F_FFFF   RAM (KSEG0 - cached)
0xA000_0000 – 0xA01F_FFFF   RAM (KSEG1 - uncached)
```

Isso é padrão MIPS:

* **KSEG0** é acesso rápido à RAM com cache
* **KSEG1** é acesso sem cache (útil para memória mapeada e DMA)

---

### **16.3.2 CPU MIPS R3000A**

O MIPS R3000A do PS1 é **inteiramente pipeline, load/store, RISC puro**, sem surpresas.
Não tem multiplicação/divisão rápidas como CPUs modernas, mas possui instruções dedicadas:

```asm
mult $t0, $t1
mfhi $t2
mflo $t3
```

E, claro, o clássico delay slot:

```asm
j loop
nop   ; executado antes de pular!
```

Se você quer “sentir” a arquitetura, aqui vai um loop feito em MIPS (estilo PS1):

```asm
loop:
    addiu $t0, $t0, -1
    bnez  $t0, loop
    nop
```

Esse tipo de construção aparece frequentemente em drivers e rotinas de inicialização.

---

### **16.3.3 Organização da RAM**

O PS1 possui **2 MB de RAM principal**, que é espremida ao extremo.
O layout típico em jogos segue algo assim:

```
[ Stack ]
[ Code / .text ]
[ Data / .data ]
[ BSS ]
[ Heap ]
[ Buffers temporários ]
```

O programador precisa ser disciplinado — ou o jogo **explode** com um crash obscuro.

Em homebrew, normalmente se usa um layout simples gerado pelo compilador GCC (mipsel-elf-gcc) ou mips-gcc.

---

### **16.3.4 A BIOS do PlayStation**

A BIOS do PS1 é um dos pontos mais interessantes do console.
Ela fornece **funções de alto nível** para:

* Gerenciar exceções
* Acessar CD-ROM
* Controlar memória
* Inicializar controladores
* Exibir texto na tela
* Alocar heap

Um trecho clássico para imprimir texto usando a função de BIOS:

```c
#include <psxapi.h>

void main() {
    FntLoad(960, 256);        // carregar fonte da BIOS
    int id = FntOpen(0, 0, 320, 240, 0, 256);

    while(1) {
        FntPrint(id, "Hello from PlayStation 1!\n");
        FntFlush(id);
        VSync(0);             // sincronizar com o quadro
    }
}
```

Esse exemplo, apesar de simples, mostra imediatamente:

1. uso da *BIOS como biblioteca*
2. fluxo típico de renderização no PS1
3. dependência do VSYNC 60 Hz

---

#### **Como chamar funções da BIOS diretamente (assembly)**

O PS1 usa o método `syscall` para chamar rotinas internas.

Por exemplo, para chamar `A0` (print char):

```asm
li   $v0, 0x3B    ; código da função BIOS
syscall
```

Outros exemplos comuns:

* `0x09` — `memcpy`
* `0x0A` — `memset`
* `0xA0-XX` — serviços básicos
* `0xB0-XX` — serviços de arquivos e kernel
* `0xC0-XX` — serviços de GPU, SPU, etc.

Se quiser chamar a função `memset` da BIOS:

```asm
li   $a0, 0x80010000   ; destino
li   $a1, 0             ; valor
li   $a2, 1024          ; tamanho
li   $v0, 0x0A          ; memset
syscall
```

Isso é útil para escrever **boot loaders**, loaders alternativos ou SOs experimentais para PS1.

---

### **16.3.5 Interrupções e exceções no PS1**

O MIPS usa a tradicional exceção via registrador **Cause** no COP0.

Exemplo simplificado de handler:

```asm
exception_handler:
    mfc0 $k0, $13      ; Cause
    mfc0 $k1, $14      ; EPC

    # lidar com TLB miss, syscall, overflow...

    jr   $k1
    rfe               ; restore from exception
```

Detalhes importantes:

* exceções empilham EPC (program counter)
* `rfe` restaura o estado privilegiado
* interrupções vêm da GPU/VBlank, CD-ROM, timers

No PS1, por exemplo, o VSync gera interrupção periódica que muitos jogos usam para organização lógica.

---

### **16.3.6 Pipeline e desempenho**

O R3000A possui pipeline simples, mas sensível:

* 5 estágios
* branch delay slot obrigatório
* loads têm *load delay*, exigindo `nop` ou reorder
* muito importante para DMA + GPU + GTE

Um código típico otimizado para cópia rápida:

```asm
copy_loop:
    lw   $t0, 0($a0)
    addiu $a0, $a0, 4
    sw   $t0, 0($a1)
    addiu $a1, $a1, 4
    bne  $a0, $a2, copy_loop
    nop
```

A performance da CPU é modesta, mas combinada com o **GTE** torna-se impressionante para padrões de 1994.

Entraremos agora na “mecânica interna” que realmente diferencia o PS1 de um sistema embarcado comum:

* controladores de DMA
* GPU baseada em primitivos 2D
* o coprocessador GTE para transformações 3D
* a relação íntima entre CPU, DMA, GPU e ordering tables

Aqui começamos a nos aproximar de algo semelhante a **estudar um SoC moderno**, mas num ambiente completamente compreensível, quase pedagógico.

---

# **16.3.7 O controlador DMA do PS1**

O PlayStation 1 possui **7 canais DMA**, cada um dedicado a um subsistema:

| Canal | Destino  | Função                          |
| ----- | -------- | ------------------------------- |
| 0     | MDEC in  | Vídeo (entrada)                 |
| 1     | MDEC out | Vídeo (saída)                   |
| 2     | GPU      | Renderização, comandos gráficos |
| 3     | CD-ROM   | Leitura do disco                |
| 4     | SPU      | Áudio                           |
| 5     | PIO      | Port I/O                        |
| 6     | OTC      | *Ordering Table Clear*          |

### Por que DMA é tão importante?

No PS1, **quase tudo que chega à GPU passa pelo DMA** — não é opcional.

A CPU **não** envia cada vértice ou primitiva diretamente para a GPU: ela monta blocos de comandos em RAM e aciona o DMA2 para transferi-los à GPU de forma rápida e ordenada.

O DMA6 (OTC) é uma invenção especialmente brilhante: ele preenche a ordering table de trás para frente, gerando uma lista encadeada que a GPU vai seguir na ordem correta.

---

## **16.3.8 Transferindo comandos para a GPU via DMA**

Um comando simples para desenhar um quadrado pode ser enviado assim:

```c
volatile uint32_t *GP0 = (uint32_t *)0x1F801810;
volatile uint32_t *DMA2_CHCR = (uint32_t *)0x1F8010A8;
volatile uint32_t *DMA2_MADR = (uint32_t *)0x1F8010A0;
volatile uint32_t *DMA2_BCR  = (uint32_t *)0x1F8010A4;
```

Suponha que montamos um pacote com comandos da GPU:

```c
uint32_t packet[8];
packet[0] = 0x60000000;      // PolyF (flat polygon)
packet[1] = 0x00FF0000;      // cor
packet[2] = (50<<16) | 50;   // (x1,y1)
packet[3] = (150<<16) | 50;  // (x2,y2)
packet[4] = (150<<16) | 150; // (x3,y3)
packet[5] = (50<<16) | 150;  // (x4,y4)
```

O envio via DMA fica assim:

```c
*DMA2_MADR = (uint32_t)packet;   // endereço na RAM
*DMA2_BCR  = (sizeof(packet)/4) | (1<<16); // número de palavras
*DMA2_CHCR = 0x01000200;         // start, direção RAM→GPU
```

Este fragmento, embora simples, é **idêntico** ao que engines reais faziam.

---

# **16.3.9 Ordering Table (OT)**

A GPU do PS1 **não possui Z-buffer**.

Em vez disso, usa-se a OT:

* uma lista encadeada
* ordenada de trás para frente
* preenchida pelo DMA6

### Fluxo típico:

1. CPU cria a OT (tamanho depende da profundidade da cena)
2. DMA6 preenche automaticamente
3. CPU insere pacotes gráficos apontando para elementos da OT
4. DMA2 envia os comandos OT→GPU

### Exemplo de clearing da OT (DMA6):

```c
*DMA6_MADR = (uint32_t)ordering_table_end;
*DMA6_BCR  = OT_SIZE;
*DMA6_CHCR = 0x01000200;   // start DMA6
```

### Inserindo primitivas:

```c
ordering_table[z] = (uint32_t)packet;
packet[0] = previous_ot_entry;
```

Um sistema simples, determinístico e extremamente rápido.

---

# **16.3.10 A GPU do PlayStation 1**

A GPU do PS1 não “desenha polígonos 3D”; ela:

* recebe triângulos já projetados (x,y)
* desenha *primitivas 2D*
* com cor, textura, shading básico

### Primitivas principais:

* Polygons: `PolyF`, `PolyG`, `PolyFT`, `PolyGT`
* Lines: `LineF`, `LineG`
* Sprites
* Tiles
* Retângulos

### Comando mais básico da GPU (GP0):

```c
// GP0(0x28) – preencher retângulo sólido
GP0( 0x28000000 | (y << 16) | x );
GP0( (height << 16) | width );
GP0( color );
```

No PS1, praticamente todo desenho começa com:

*OT limpa → pacotes de primitivas → DMA2 → GPU*

---

# **16.3.11 O coprocessador GTE**

O **GTE** é o “motor 3D” do PS1, mas ele não renderiza nada.

Ele calcula:

* transformações 3D → 2D
* projeção
* iluminação
* normalização
* clipping

Por exemplo:

```
[3D vertices] --(GTE)--> [projected vertices] --(DMA)--> [GPU]
```

### Exemplo real: transformação de um vetor

```c
// Setup: Load rotation matrix and translation vector:

gte_SetRotMatrix(&rot);
gte_SetTransMatrix(&trans);

// Input vertex:
VECTOR v = {100, 200, 300};

// Output:
VECTOR out;

// Execute transformation:
gte_ldv0(&v);      // load vertex 0
gte_rtps();        // run transform, project, clamp
gte_stsxy0(&out);  // store result
```

Esse pequeno trecho era literalmente a base de engines do PS1.

---

# **16.3.12 Pipeline completo de um frame PS1**

Um frame típico (60 Hz) do PS1 passava por:

### **(1) VSync interrupt**

* GPU termina o quadro anterior
* CPU prepara buffers e OT do próximo

### **(2) Clear da Ordering Table**

DMA6 limpa rapidamente.

### **(3) Transformação 3D**

* CPU/GTE calculam coordenadas projetadas

### **(4) Geração de comandos na RAM**

* CPU monta pacotes de primitives
* Insere nas OTs conforme z-order

### **(5) DMA2 → GPU**

* GPU recebe blocos inteiros de comandos

### **(6) GPU rasteriza**

* sem envolvimento da CPU
* sem Z-buffer
* sem shaders, sem pipeline programável

---

# **16.3.13 Um “Hello Triangle” completo para PS1**

Este exemplo usa psn00bsdk (C moderno), mas reflete o hardware real:

```c
#include <psx.h>

int main() {
    // Inicialização padrão
    InitializePads();
    ResetGraph(0);

    // Load font
    FntLoad(960, 256);
    int fnt = FntOpen(0,0,320,240,0,256);

    // Ordering Table
    uint32_t ot[1 << 5]; // 32 níveis de profundidade
    PACKET packets[128];

    while (1) {
        // Sincroniza com o VBlank
        VSync(0);

        // Limpa OT via DMA6
        ClearOTagR(ot, 32);

        // Monta um triângulo simples
        POLY_F4 *poly = (POLY_F4*) packet;

        setPolyF4(poly);
        setRGB0(poly, 255, 0, 0);

        setXY4(poly, 
            100,100,
            200,100,
            150,150,
            80,150
        );

        // Insere no OT
        addPrim(&ot[0], poly);

        // Envia para a GPU
        DrawOTag(ot);

        // Texto
        FntPrint(fnt, "Hello Triangle on PS1!\n");
        FntFlush(fnt);
    }
}
```

Esse programa já gera:

* um triângulo vermelho
* texto via BIOS
* fluxo DMA → GPU correto
* sincronização VSync real

É literalmente o “Olá Mundo” moderno do PS1.

---

# **16.3.14 Conectando tudo: por que o PS1 é tão didático**

Do ponto de vista de sistemas embarcados:

### **O PS1 é um estudo completo de:**

✔️ CPU RISC real (MIPS)
✔️ organização de memória
✔️ DMA com múltiplos canais
✔️ GPU “determinística”, sem abstrações
✔️ coprocessador matemático dedicado
✔️ BIOS acessível por syscalls
✔️ interrupções e exceções claras
✔️ sistema sem MMU (no modo kernel do jogo)

Tudo que um novo projetista embarcado precisa aprender — mas com a vantagem de poder montar **um motor gráfico completo em poucas páginas de código**.

