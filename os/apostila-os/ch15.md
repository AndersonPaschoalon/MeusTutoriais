# **Capítulo 15 — Estudos de Casos Práticos**

---

## **15.1 — Sistema de Aquisição de Dados com FreeRTOS**

#### **Objetivo do caso**

Construir um pequeno sistema que:

* lê dados de sensores periodicamente
* processa/filtra
* envia para algum barramento (UART, CAN, etc.)
* garante sincronização e prioridade com FreeRTOS

---

#### **Arquitetura típica**

Um sistema de aquisição clásssico com FreeRTOS costuma ter ao menos **três tarefas principais**:

#### **1. Task de Leitura (Amostragem)**

* Executa com prioridade média ou alta.
* Período preciso → usa *vTaskDelayUntil()* ou hardware timer.
* Lê o sensor (I2C, ADC, SPI).
* Envia o valor bruto para uma *queue* ou *stream buffer*.

#### **2. Task de Processamento**

* Prioridade média.
* Aguarda dados da Task de Leitura via *xQueueReceive()*
* Executa filtros simples: moving average, low-pass, linearização, compensações térmicas.
* Publica resultado em outra *queue*.

#### **3. Task de Comunicação**

* Prioridade baixa.
* Recebe resultados já processados e envia via UART/USB/LoRa/Ethernet.
* A prioridade é baixa porque comunicação pode ser lenta.

#### **Fluxo geral**

```
[Sensor/ADC] → Task Leitura → Queue → Task Processamento → Queue → Task Comunicação
```

---

#### **Mecanismos FreeRTOS úteis**

* **Queues** → passagem de dados com cópia, simples e segura
* **Stream Buffer / Message Buffer** → ótimo para amostras contínuas
* **Semaphore Binário** → sincronizar interrupções (ex: IRQ de ADC)
* **Mutex** → proteger acesso a periféricos compartilhados (I2C, UART)

---

#### **Garantindo temporização correta**

Para leitura periódica determinística:

```c
TickType_t last = xTaskGetTickCount();
for(;;) {
    read_sensor();
    vTaskDelayUntil(&last, pdMS_TO_TICKS(10));  // 100 Hz
}
```

**Boa prática:** *Nunca* usar apenas vTaskDelay() para loops periódicos — o drift acumula.

---

#### **Pitfalls comuns**

1. **Queue cheia** → aumenta latência e perde amostras
2. **Prioridade errada** → comunicações travam a leitura
3. **ES hacks** (ex.: fazer processamento dentro de ISR) → gera jitter
4. **I2C lento** → bloquear Task de aquisição por 10 ms causa backlog

---

#### **Checklist rápido de projeto**

* [x] tamanho das queues dimensionado para picos de carga
* [x] processamentos curtos (≤ 10% do período da tarefa)
* [x] usar DMA para ADC/I2C, se possível
* [x] comunicação deve ser a última etapa (baixa prioridade)

---

---

## **15.2 — Controle de Motor em Tempo Real**

#### **Objetivo do caso**

Projeto que controla a velocidade ou posição de um motor:

* motor DC → PWM + controle de velocidade (PID)
* motor BLDC → comutação + sensor Hall
* motor servo → controle de posição

Exemplo: controle PID a 1 kHz.

---

#### **Componentes principais**

#### **1. ISR/TIMER (Loop de Controle)**

* Frequência alta (500 Hz – 20 kHz)
* Executa **exatamente** no período definido
* Calcula PID (ou outro controlador)
* Atualiza duty cycle do PWM

#### **2. Task de Supervisão (FreeRTOS)**

* Lê comandos (target_speed, torque, duty max).
* Ajusta parâmetros do controlador.
* Faz telemetria (ex.: envio de logs).
* Prioridade baixa.

#### **Fluxo**

```
            (comando)
 Task Supervisão ------→ Variáveis de controle
                             ↑      |
                             |      ↓
                          Timer ISR —→ PWM
                           (PID)
```

---

#### **Por que o controle deve estar em interrupção?**

Porque o PID depende da constante **dt** extremamente regular.
FreeRTOS não garante 100% de determinismo para taxas tão altas.
Mas como boa prática:

* ISR deve ser mínima (só o essencial).
* Nunca rodar comunicação dentro da ISR.

---

## **Variação prática (BLDC)**

Para BLDC:

* leitura de sensores Hall a cada borda
* timer controla avanço do vetor
* PID controla torque/velocidade

---

#### **Cálculo PID simplificado**

```c
error = target - measurement;
I += error * dt;
D = (error - last_error) / dt;
output = Kp*error + Ki*I + Kd*D;
last_error = error;
pwm_set(output);
```

---

#### **Pitfalls comuns**

1. **PID dentro de Task** → jitter → motor oscila
2. **Uso de float** em MCU pequeno → lento; prefira Q15 / fix-point
3. **Saturação de I (windup)**
4. **Mau dimensionamento do dt**
5. **PWM muito baixo** → motor “trava”

---

---

## **15.3 — Monitoramento IoT com MQTT e LWIP**

#### **Objetivo do caso**

Construir uma aplicação IoT com TCP/IP usando LWIP (stack leve muito comum em MCUs).

Fluxo típico:

1. coleta dados
2. monta payload JSON
3. publica MQTT
4. reconecta automaticamente
5. gerencia low-power

---

#### **Arquitetura típica**

#### **1. Tarefa de Rede**

* Executa o loop do LWIP (tcpip_thread).
* Trata conexões, pacotes e timeouts.
* Geralmente deve rodar com prioridade alta.

#### **2. Tarefa de Aplicação**

* Faz login MQTT
* Envia heartbeats
* Publica valores
* Faz parse de comandos (ex.: “ligar led”)

#### **3. Tarefa de Sensoriamento**

* Igual ao caso do 15.1 (leitura → processamento)

---

### **Fluxo de publicação**

```
Processamento → Fila → Task MQTT → lwIP → Broker
```

---

### **Problemas comuns**

* reconexão MQTT mal implementada
* não tratar timeouts TCP
* falta watchdog → dispositivo trava após 2 dias
* fila de mensagens cresce indefinidamente se rede cai

---

### **Boas práticas**

* limite máximo de mensagens na fila
* backoff exponencial para reconnect
* pacotes pequenos (evitar JSON gigante)
* uso de mensagens retain quando relevante
* usar **QoS 1** para confiabilidade
* manter task de rede com prioridade maior

---


## **15.4 — Implementação de Watchdog e Fail-Safe**

Um dos casos mais importantes em sistemas embarcados.

#### **Objetivo**

Garantir que o sistema **se recupere sozinho** quando algo trava, entra em deadlock ou fica lento.

---

#### **Componentes**

#### **1. Hardware Watchdog (WDT)**

* temporizador independente
* se não for “alimentado” dentro do tempo → reset
* roda mesmo se CPU travar

#### **2. Janela de segurança**

Alguns watchdogs são *windowed*:

* **early kick** → erro
* **late kick** → reset
  Isso evita “kicks” automáticos mal feitos.

---

#### **3. Fail-safe**

* detectar erro antes que o WDT dispare
* entrar em modo seguro
* salvar estado mínimo (ex.: última medida, contador, flags)
* reiniciar de forma controlada

---

#### **Fluxo recomendado**

```
Tasks → Supervisor (health check) → WDT Kick
```

Nunca “chutar” o watchdog dentro de tasks individuais — desastre garantido.

---

#### **Checkpoints típicos**

O supervisor verifica a cada ciclo:

* task A atualizou timestamp?
* buffers não estouraram?
* CPU idle abaixo do esperado?
* heap fragmentado?
* fila de eventos não está travada?

---

---

## **15.5 — Integração de Sensores e Atuadores**

#### **Objetivo**

Descrever a camada prática que liga o mundo físico ao software:

* leitura de sensores (I2C, SPI, ADC, UART)
* escrita em atuadores (PWM, GPIO, DAC, drivers externos)

---

#### **Camadas de software bem projetadas**

```
App Layer
↑
Drivers (HAL)
↑
BSP (board support)
↑
Hardware real
```

---

#### **1. Sensores**

Para cada sensor:

* driver de baixo nível
* inicialização (I2C, SPI)
* leitura periódica
* compensação
* conversão para unidades reais (°C, Pa, lux, etc.)

#### Problemas típicos

* pulls-ups insuficientes no I2C
* oversampling causando latência
* ruído analógico em ADC
* calibragem ruim

---

#### **2. Atuadores**

PWM para motores/servos
GPIO para relés
DAC para controle analógico
drivers de potência (ponte H, MOSFETs)

#### Padrões essenciais

* rampas de aceleração/desaceleração
* debouncing
* limitação de corrente
* fail-safe em caso de perda de comunicação

---

#### **3. Testes**

* testes em loop (pinos cruzados)
* mocks → simular sensores
* logs UART
* triggers de osciloscópio

