# **Capítulo 14 — Ferramentas e Ambientes**

*(No espírito de Tanenbaum: “bons sistemas não surgem espontaneamente; eles são cultivados com boas ferramentas, método e persistência”)*

Este capítulo apresenta as ferramentas que sustentam o desenvolvimento embarcado profissional. Alguns iniciantes acreditam que firmware é apenas código C mais compilador — mas na prática, para produzir algo confiável, repetível e escalável, é preciso uma cadeia inteira de utilidades, automações e ambientes especializados.

---

## **14.1 IDEs e Toolchains (GCC, CMake, PlatformIO, etc.)**

Se há algo onipresente no mundo embarcado, é o fato de que **ninguém usa apenas o editor de texto**. Pelo menos não por muito tempo. Ferramentas de construção (toolchains), organizadores de dependências e IDEs inteiros surgiram para domar a complexidade crescentemente selvagem do hardware moderno.

#### **GCC / G++ (arm-none-eabi-gcc)**

É o compilador mais comum para microcontroladores ARM Cortex-M.

Exemplo de compilação manual:

```bash
arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -O2 -c src/main.c -o build/main.o
```

E linkagem:

```bash
arm-none-eabi-gcc build/*.o -T linker/stm32f4.ld -o firmware.elf
```

#### **CMake**

CMake é especialmente útil para projetos embarcados portáveis.
Um `CMakeLists.txt` típico:

```cmake
cmake_minimum_required(VERSION 3.15)
project(meu_firmware C)

set(CMAKE_C_COMPILER arm-none-eabi-gcc)
set(CMAKE_C_FLAGS "-mcpu=cortex-m4 -mthumb -O2")

add_executable(firmware.elf
    src/main.c
    src/drivers/uart.c
)

target_link_options(firmware.elf PRIVATE -Tlinker/stm32f4.ld)
```

CMake brilha quando o projeto cresce, especialmente com RTOS, middleware, pilhas de rede, etc.

#### **PLATFORMIO**

Uma das ferramentas mais amigáveis para iniciantes e equipes:

* gestores automáticos de dependências;
* centenas de placas e MCUs suportados;
* integração com VS Code;
* upload e monitor serial embutidos;
* scripts avançados de build.

`platformio.ini` típico:

```ini
[env:bluepill_f103c8]
platform = ststm32
board = bluepill_f103c8
framework = stm32cube
upload_protocol = stlink
build_flags = -O2
```

É uma espécie de *npm + make + CMake + gerenciador de dispositivos* em um único pacote.

---

## **14.2 Simuladores e Emuladores**

O hardware real é precioso, lento e difícil de depurar.
A solução? Criar mundos artificiais — simuladores e emuladores — onde podemos experimentar sem medo.

#### **QEMU**

QEMU é provavelmente o emulador mais versátil.

Para ARM Cortex-M:

```bash
qemu-system-arm -M stm32-p103 -kernel firmware.elf -serial stdio
```

Isso permite:

* testes unitários embarcados rodando em CI;
* depuração via GDB sem hardware real;
* simulação de memória, periféricos e interrupções.

#### **Simuladores de fabricantes**

* **Renesas e2studio**
* **Microchip MPLAB X Simulator**
* **STMicroelectronics STM32CubeIDE Debugger (com simulação parcial)**

#### **Simuladores de sensores e periféricos**

Ferramentas como **Renode** simulam não só o MCU, mas *todo o sistema embarcado*, incluindo:

* rádios BLE,
* barramentos I²C/SPI,
* displays,
* flash externa.

Exemplo de execução em Renode:

```bash
renode script.resc
```

Onde `script.resc` configura a plataforma imitando o hardware real.

---

## **14.3 Monitores Seriais e Logs**

Poucas coisas são tão universais em sistemas embarcados quanto o bom e velho **monitor serial**.
Ele é simultaneamente:

* console,
* debugger,
* coletor de logs,
* shell interativo,
* meio de atualização,
* ferramenta de diagnóstico.

#### **Ferramentas comuns**

* `minicom`
* `screen`
* `picocom`
* `Putty`
* terminal do PlatformIO / VS Code

Exemplo:

```bash
minicom -D /dev/ttyUSB0 -b 115200
```

#### **Protocolos de logging**

Para logs estruturados:

* JSON serializado,
* CBOR,
* Protobuf,
* Logs binários compactos (muito comuns em telemetria LoRa e BLE).

#### **Exemplo simples de logger UART**

```c
void log_info(const char *msg)
{
    uart_write("[INFO] ");
    uart_write(msg);
    uart_write("\r\n");
}
```

No estilo Tanenbaum:

> “Se você não está registrando o que seu firmware faz, então você está apenas torcendo para que nada dê errado — o que historicamente nunca funcionou.”

---

## **14.4 Sistemas de Versionamento e CI/CD Embarcado**

Hoje é impensável desenvolver firmware sério sem versionamento.
E o mundo embarcado, apesar de tradicionalmente “conservador”, finalmente abraçou CI/CD.

#### **Git — a espinha dorsal**

Fluxo comum:

* `main`: versões estáveis;
* `develop`: integração contínua;
* `feature/*`: novas funcionalidades;
* `hotfix/*`: correções imediatas.

Commits devem sempre capturar:

* número da versão do firmware,
* estado do linker script,
* configurações críticas do clock,
* checksum/assinatura do release.

#### **CI/CD para firmware**

Ferramentas como:

* GitHub Actions
* GitLab CI
* Jenkins
* Azure DevOps

...podem compilar firmware automaticamente, rodar testes unitários e publicar *artifacts*.

#### **Pipeline típico**

```
build:
  - instalar toolchain ARM
  - rodar unit tests
  - compilar firmware
  - rodar simulador (QEMU/Renode)
  - validar tamanho da imagem
  - gerar firmware.bin/hex
  - assinar firmware
  - publicar artefato
  - disparar atualização OTA (opcional)
```

Exemplo de pipeline (GitHub Actions):

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install ARM GCC
        run: sudo apt-get install gcc-arm-none-eabi
      - name: Build
        run: make
      - name: Run QEMU tests
        run: ./scripts/run_qemu.sh
      - name: Upload firmware
        uses: actions/upload-artifact@v3
        with:
          name: firmware
          path: build/firmware.bin
```

---

## **14.5 Integração com Hardware-in-the-Loop (HIL)**

À medida que um sistema cresce, torna-se inviável testar tudo somente em simulação ou manualmente. É aí que entra o **HIL — Hardware-In-The-Loop**.

#### **O que é HIL?**

É a prática de testar firmware usando:

* hardware real (ou parcialmente real),
* conectado a instrumentos automatizados,
* controlados por scripts ou CI/CD.

Em outras palavras:

**Você coloca o mundo real dentro do pipeline automático.**

#### **Componentes típicos de um setup HIL**

* uma ou mais placas embarcadas;
* relés ou dispositivos programáveis para acionar botões;
* sensores simulados (DACs, geradores PWM, módulos I²C virtuais);
* equipamentos de teste (osciloscópio, lógico-analisador);
* computador de automação rodando Python ou C;
* scripts automatizando resets, flash e leitura de logs.

#### **Exemplo simples de script HIL em Python**

```python
import serial
import subprocess
import time

# Flash da placa
subprocess.run(["st-flash", "write", "firmware.bin", "0x8000000"])

# Conecta no serial
ser = serial.Serial("/dev/ttyUSB0", 115200)

time.sleep(1)
ser.write(b"RUN_TEST\r\n")

output = ser.readline().decode()
print("Resultado:", output)

if "OK" not in output:
    raise Exception("Teste falhou!")
```

Esse tipo de automação permite validar:

* boot do firmware,
* respostas do sistema,
* comunicações UART/SPI/I²C,
* handling de erros,
* comportamento de watchdog.

### **Por que HIL é indispensável?**

Tanenbaum provavelmente diria algo assim:

> “Simuladores são maravilhosos, mas eles têm um defeito fatal: ao contrário do hardware real, eles sempre se comportam.”

No hardware real, há:

* jitter,
* EMI,
* flutuação de tensão,
* glitches de clock,
* sensores que travam,
* periféricos que demoram mais que o esperado.

E somente HIL captura isso.

