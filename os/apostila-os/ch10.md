# **Capítulo 10 — Comunicação entre Dispositivos**

## **10.1 Protocolos de comunicação serial (UART, SPI, I²C, CAN)**

Quando dois dispositivos desejam conversar no mundo digital, precisam antes concordar em um idioma — seu conjunto de sinais elétricos, tempos, convenções de início e fim, e até sobre quem fala primeiro. Nos computadores pessoais, esse “idioma” costuma ser abstraído por camadas e camadas de protocolos. Já em sistemas embarcados, essas convenções descem ao nível do fio de cobre.

Aqui, cada bit importa. Literalmente.

O engenheiro de sistemas embarcados precisa compreender não somente o que está sendo enviado, mas como e quando. Afinal, um microcontrolador típico conversa diariamente com sensores, atuadores, memórias, rádios, displays… e cada um usa um dialeto diferente. Nesta seção analisaremos os quatro protocolos seriais mais tradicionais: **UART, SPI, I²C e CAN**.

---

### **10.1.1 UART — o velho telefone de dois fios**

Historicamente, UART (Universal Asynchronous Receiver/Transmitter) é talvez o protocolo mais antigo e onipresente ainda em uso. Sua popularidade deriva da simplicidade: dois dispositivos, um fio para transmitir (TX), outro para receber (RX), e pronto. Nada de clock compartilhado, nada de topologias complicadas.

É como um telefone com fio, em que cada participante sabe com que velocidade o outro fala. Se ambos concordam em falar a 9600 palavras por segundo, a conversa flui. Se um fala a 115200 e outro a 4800, conversas serão dignas de um rádio mal sintonizado.

#### **Formato do quadro UART**

Um quadro UART típico pode ser ilustrado assim:

```
Start | Data bits | Parity | Stop
  0   |   8 bits  | opcional | 1 ou 2 bits em 1
```

A borda de descida do bit de start anuncia que uma palavra está chegando. A partir daí, o receptor assume que o transmissor manterá o timing perfeitamente — o que, claro, pode não ocorrer, tornando UART vulnerável a jitter e drift de clock.

Apesar disso, é ideal para **debug**, **telemetria simples**, **configurações** e sensores legados.

### **Exemplo: Inicializando UART em C (bare-metal ARM Cortex-M)**

A seguir um exemplo bem resumido para STM32 (registradores reais, estilo didático):

```c
// Configura USART2 a 115200 baud, 8N1
void uart2_init(void) {
    // Habilita clock do GPIOA e USART2
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    // Configura PA2 como TX e PA3 como RX (alternate function AF7)
    GPIOA->MODER &= ~((3 << (2*2)) | (3 << (3*2)));   // limpa MODER
    GPIOA->MODER |=  ((2 << (2*2)) | (2 << (3*2)));   // modo AF
    GPIOA->AFR[0] |= (7 << 8) | (7 << 12);            // AF7

    // Configura baud rate (assumindo 16 MHz)
    USART2->BRR = 16000000 / 115200;

    // Habilita USART: TX, RX e módulo
    USART2->CR1 |= USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;
}

void uart_write(char c) {
    while (!(USART2->SR & USART_SR_TXE)); // espera buffer vazio
    USART2->DR = c;
}
```

Nada mais Tanenbaum do que manipular registradores e explicar que “um simples bit configurado incorretamente faz o sistema entrar em colapso”.

---

### **### 10.1.2 SPI — comunicação serial com esteroides**

Se UART é uma ligação telefônica, **SPI (Serial Peripheral Interface)** é mais parecido com um sistema de rádio militar de quatro canais, todos sincronizados por um relógio central.

Ele utiliza:

* **MOSI** — Master Out Slave In
* **MISO** — Master In Slave Out
* **SCLK** — Clock
* **SS / CS** — Chip Select (um por escravo)

SPI é **síncrono**: o clock é fornecido pelo mestre. Com isso, é extremamente mais estável e rápido do que UART, frequentemente alcançando **dezenas de MHz**.

#### Vantagens

* Altíssima velocidade
* Comunicação full-duplex
* Protocolo simples (quase nenhum overhead)
* Ideal para displays, memórias Flash, rádios, sensores de alta velocidade

#### Desvantagens

* Requer muitos fios
* Escalabilidade ruim (muitos slaves = muitos CS)
* Topologia radial, não multi-mestre

#### Exemplo: Leitura de memória SPI Flash (pseudocódigo Linux driver)

```c
// Função simplificada de leitura de uma memória SPI NOR
int spi_flash_read(struct spi_device *spi, u32 addr, u8 *buf, size_t len) {
    u8 cmd[4];
    cmd[0] = 0x03; // READ
    cmd[1] = (addr >> 16) & 0xFF;
    cmd[2] = (addr >> 8) & 0xFF;
    cmd[3] =  addr & 0xFF;

    struct spi_transfer t[2] = {
        {.tx_buf = cmd, .len = 4},
        {.rx_buf = buf, .len = len},
    };

    return spi_sync_transfer(spi, t, 2);
}
```

Aqui vemos como o Linux realmente faz — através de `spi_transfer` estruturado — uma bela abstração sobre o caos elétrico dos fios.

---

### **10.1.3 I²C — dois fios, muitos dispositivos**

O barramento **I²C** foi criado pela Philips com uma ideia simples: *e se todos os dispositivos pudessem compartilhar apenas dois fios?* Assim nasceram SDA (dados) e SCL (clock), ambos de propósito múltiplo e drenagem aberta (open-drain).

Diferente de SPI, I²C suporta:

* múltiplos mestres
* vários escravos
* endereços de 7 ou 10 bits
* detecção de colisão (arbitragem por nível lógico)

É perfeito para sensores, RTCs, expanders de GPIO e periféricos de baixa/média velocidade.

#### O protocolo I²C é mais complexo que parece

Um frame simplificado:

```
START
ADDR (7 bits) + R/W
ACK
DATA
ACK
...
STOP
```

Tudo isso operando em faixas de até 400 kHz (Standard/Fast), ou até alguns MHz em Fast Mode Plus.

#### Exemplo: leitura de registrador em I²C (bare-metal)

```c
uint8_t i2c_read_reg(uint8_t dev, uint8_t reg) {
    i2c_start();

    i2c_write((dev << 1) | 0); // Write mode
    i2c_write(reg);

    i2c_start();               // Repeated start
    i2c_write((dev << 1) | 1); // Read mode
    uint8_t val = i2c_read_nack();

    i2c_stop();
    return val;
}
```

Notável é o famoso **repeated start**, que evita perder controle do barramento.

---

### **### 10.1.4 CAN — comunicação para ambientes hostis**

O barramento **CAN (Controller Area Network)** foi projetado para automóveis e ambientes onde falhas não são opcionais: são esperadas. Em outras palavras, o inesperado é parte do projeto.

Aqui, cada mensagem tem **ID de prioridade**, e o próprio barramento resolve contendas eletricamente. Um exemplo da elegância do CAN é que, em uma colisão, o dispositivo com ID mais prioritário automaticamente vence — sem retransmissões desnecessárias.

#### Características marcantes

* Alta imunidade a ruído
* Topologia multi-mestre
* Até ~1 Mbps no CAN clássico
* Frames com CRC, ACK explícito, bits de stuffing
* CAN FD permite quadros muito maiores e rápidos

#### Formato simplificado do frame CAN

```
SOF | Arbitration ID | Control | Data (0-8 bytes) | CRC | ACK | EOF
```

#### Exemplo: handler de interrupção de CAN em STM32 (estilo real)

```c
void CAN1_RX0_IRQHandler(void) {
    if (CAN1->RF0R & CAN_RF0R_FMP0) { // FIFO tem mensagem
        CAN_RxMsgTypeDef msg;

        msg.StdId = (CAN1->sFIFOMailBox[0].RIR >> 21) & 0x7FF;
        msg.DLC   = CAN1->sFIFOMailBox[0].RDTR & 0xF;

        for (int i = 0; i < msg.DLC; i++) {
            msg.Data[i] = (CAN1->sFIFOMailBox[0].RDLR >> (8*i)) & 0xFF;
        }

        // Processa mensagem (aplicação)
        handle_can_message(&msg);

        // Libera FIFO
        CAN1->RF0R |= CAN_RF0R_RFOM0;
    }
}
```

Observe como o hardware entrega a maior parte do trabalho pronto: IDs, DLC, buffers organizados — o programador apenas extrai e responde.


## **10.2 Protocolos de rede (Ethernet, TCP/IP, LWIP)**

A comunicação serial, como vimos, é extremamente útil quando dois dispositivos estão próximos — literalmente a centímetros de distância. Mas à medida que sistemas embarcados passaram a integrar máquinas industriais, automóveis, robôs, drones e dispositivos IoT espalhados por cidades inteiras, tornou-se evidente que “dois fios e um clock” já não eram suficientes.

Era necessário um protocolo universal. Um que permitisse conectar máquinas por metros, quilômetros ou continentes. E que sobrevivesse ao caos da comunicação real, onde pacotes se perdem, cabos quebram, e bits chegam corrompidos como palavras na chuva.

Assim surgiram **Ethernet**, **IP**, **TCP**, **UDP**, e todo o ecossistema de rede que domina o planeta.
E, nos sistemas embarcados, tudo isso é frequentemente implementado por **LWIP**, uma stack TCP/IP compacta e eficiente.

---

### **10.2.1 Ethernet — a base física e de enlace**

Ethernet é o equivalente moderno de um conjunto de cartas enviadas por mensageiros que percorrem corredores compartilhados. Há um meio físico, há colisões, há um organismo responsável por endereçar as “casas” (endereços MAC), e há regras claras de convivência.

Nas versões antigas (10BASE-T), Ethernet era como uma conversa de bar — todos falando no mesmo fio (o famoso CSMA/CD). Hoje, com switches full-duplex, a conversa é muito mais organizada: cada porta conversa apenas com o seu interlocutor.

#### Frame Ethernet (simplificado)

```
| Dest MAC | Src MAC | EtherType | Payload | CRC |
```

O campo EtherType indica o que vem depois: IPv4? ARP? IPv6?

O CRC (FCS) garante que erros sejam detectados ainda na camada 2.

#### Exemplo real: sniff de pacote com tcpdump

```
12:23:10.123456 ethertype IPv4 (0x0800), length 98:
    192.168.0.10.5000 > 192.168.0.4.1234: Flags [P.], seq 1:49, ack 1
```

Se você já fez debug de rede em um microcontrolador usando **Wireshark**, sabe o quanto isso salva vidas — e reputações.

---

### **10.2.2 TCP/IP — a pilha lógica que dá sentido aos bytes**

Quando Tanenbaum escreveu sobre redes de computadores, descreveu a pilha TCP/IP como uma “engenhoca engenhosa sobreposta a outra engenhoca”. E tinha razão.

A pilha funciona como um condomínio organizado:

* **Ethernet** entrega pacotes dentro do prédio;
* **IP** cuida de endereços entre edifícios;
* **TCP e UDP** definem como os moradores conversam entre si;
* **Aplicações** interpretam o conteúdo: HTTP, MQTT, Modbus/TCP…

#### IP: O carteiro do sistema

O protocolo IP é *não confiável*: entrega se puder, descarta se necessário. Nada de garantias.
Seu papel é rotear pacotes pelo labirinto da rede.

#### TCP: A conversa educada

TCP cria um canal confiável usando mecanismos como:

* Handshake 3-way
* Numeração de sequência
* Retransmissões e ACKs
* Controle de congestionamento

É como dois interlocutores que confirmam cada frase antes de seguir.

#### UDP: “Joga na rede e torce”

UDP é minimalista e rápido — usado para streaming, jogos, telemetria.
Se o pacote se perder, paciência.

---

### **10.2.3 LWIP — TCP/IP no microcontrolador**

LWIP (Lightweight IP), criado por Adam Dunkels, é o milagre que permite rodar TCP/IP em um microcontrolador com 64 KB de RAM sem que o sistema imploda.

Ele implementa:

* ARP
* IPv4 / IPv6
* ICMP
* UDP
* TCP
* DHCP, DNS (opcionais)

E o faz utilizando uma combinação engenhosa de:

* buffers extremamente compactos
* callbacks
* modo raw (sem sockets)
* opcionalmente BSD sockets

#### Arquitetura simplificada

```
NIC Driver <-> LWIP Low-level <-> IP/TCP/UDP <-> Application
```

#### O papel crucial do **driver Ethernet**

LWIP não fala diretamente com o hardware. Quem cuida disso é o *low-level driver*, que deve:

* Receber frames da MAC/PHY
* Entregar à função `ethernet_input()`
* Enviar pacotes usando `low_level_output()`

Uma implementação ruim do driver arruína toda a pilha — e isso acontece com frequência em projetos amadores.

---

### **10.2.4 Exemplo real: socket TCP com LWIP (modo BSD)**

Este é um código *realista*, retirado e simplificado de aplicações baseadas em FreeRTOS + LWIP:

```c
void tcp_server_task(void *arg) {
    int sock, client;
    struct sockaddr_in addr, client_addr;
    socklen_t addr_len = sizeof(client_addr);

    sock = lwip_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = INADDR_ANY;

    lwip_bind(sock, (struct sockaddr *)&addr, sizeof(addr));
    lwip_listen(sock, 2);

    while (1) {
        client = lwip_accept(sock, (struct sockaddr *)&client_addr, &addr_len);
        lwip_write(client, "Hello from MCU!\n", 17);
        lwip_close(client);
    }
}
```

A beleza disto?
Um microcontrolador de poucos megahertz, muitas vezes sem MMU, está agindo como um servidor de rede.

---

### **10.2.5 Exemplo raw API no LWIP (sem sockets)**

A versão raw exige mais cuidado, mas consome muito menos RAM:

```c
// Callback quando dados chegam
err_t tcp_recv_callback(void *arg, struct tcp_pcb *tpcb,
                        struct pbuf *p, err_t err) {

    if (p == NULL) {
        tcp_close(tpcb);
        return ERR_OK;
    }

    tcp_write(tpcb, p->payload, p->len, TCP_WRITE_FLAG_COPY);
    tcp_recved(tpcb, p->len);
    pbuf_free(p);

    return ERR_OK;
}

void tcp_init_server(void) {
    struct tcp_pcb *pcb = tcp_new();
    tcp_bind(pcb, IP_ADDR_ANY, 8888);

    pcb = tcp_listen(pcb);
    tcp_accept(pcb, tcp_accept_callback);
}
```

O programador tem controle total — e responsabilidade total.
Um erro aqui (ex.: não chamar `tcp_recved`) pode destruir o desempenho.

---

### **10.2.6 Desafios reais em redes embarcadas**

Não é por acaso que sistemas embarcados com rede são notoriamente difíceis:

* **latência de interrupção** aumenta com tráfego intenso
* **pbuf leaks** causam esgotamento de memória
* drivers MAC mal implementados causam overruns
* o PHY pode entrar em estados estranhos devido a ruído ou quedas de energia
* ARP cache pode se tornar inconsistente
* DHCP pode falhar em condições de congestão
* TCP, por si só, pode consumir dezenas de kilobytes de RAM

Todo projeto Ethernet embarcado precisa lidar com diagnósticos: counters, estatísticas, watchdogs, dumps de pbuf, timeouts de link, e reinicialização de interface.


## **10.3 Sincronização de tempo (NTP, PTP)**

O tempo é, por si só, uma ilusão útil — mas em sistemas embarcados ele se torna um recurso técnico fundamental. Dois sensores que registram eventos sem relógios sincronizados não podem gerar correlação precisa; dois controladores industriais que acionam motores sem uma referência temporal comum podem destruir equipamentos; dois robôs que se movem sem coordenadas temporais alinhadas podem literalmente colidir.

Portanto, a sincronização de tempo surge como um requisito essencial tanto em sistemas distribuídos clássicos quanto em dispositivos embarcados modernos.

Nesta seção, faremos como Tanenbaum faria: começaremos com o problema conceitual, evoluindo para os mecanismos práticos, e finalizando com exemplos reais baseados em microcontroladores.

---

### **10.3.1 O problema da sincronização de relógios**

Imagine um sistema com três dispositivos:

* Sensor A: registra temperatura
* Sensor B: registra vibração
* Controlador C: gera alarmes quando o aumento de temperatura precede vibração em até 20 ms

Para que o alarme seja confiável, os três dispositivos precisam de um **tempo compartilhado**. Mas microcontroladores usam osciladores com drift (deriva) — alguns chegam a *30–100 ppm* de erro, o que resulta em vários milissegundos de discrepância em poucas horas.

Sem sincronização de tempo:

```
Sensor A: evento às 10:00:00.001
Sensor B: evento às 10:00:00.003
Controlador: interpreta B como ocorrendo antes de A → comportamento incorreto
```

Com sincronização:

```
Ambos usam um tempo global e consistente → análise correta
```

É aqui que entram **NTP** (preciso na ordem de milissegundos) e **PTP** (preciso na ordem de microssegundos ou até sub-microsegundos).

---

### **10.3.2 NTP — Network Time Protocol**

O NTP é o veterano do mundo da sincronização de tempo. Foi projetado na década de 1980 para computadores em redes grandes e lentas. Em sistemas embarcados modernos, ainda é amplamente utilizado — especialmente quando precisão de milissegundos é suficiente.

#### **Como funciona o NTP**

A ideia central é simples: medir *latência* e *offset* de tempo entre cliente e servidor.

Um cliente envia um pacote contendo o *timestamp local de envio*. O servidor devolve um pacote contendo:

* horário em que recebeu
* horário em que enviou

Com esses quatro tempos, o cliente estima:

* o **offset** (diferença entre relógios)
* o **delay** (latência de ida e volta)

A famosa fórmula é:

```
offset = ((t2 - t1) + (t3 - t4)) / 2
delay  = (t4 - t1) - (t3 - t2)
```

Onde:

* t1: cliente envia req
* t2: servidor recebe
* t3: servidor envia resp
* t4: cliente recebe resp

#### **Precisão típica**

* Internet: 10–100 ms
* LAN estável: 1–5 ms
* Embarcados com RTC ruim: ~10 ms devido a drift

#### **Exemplo real LWIP: sincronização NTP**

LWIP oferece um cliente NTP simples, que pode ser acionado periodicamente:

```c
#include "lwip/apps/sntp.h"

void ntp_sync_init(void) {
    sntp_setoperatingmode(SNTP_OPMODE_POLL);
    sntp_setservername(0, "pool.ntp.org");
    sntp_init();
}
```

Quando o servidor NTP responde, LWIP chama internamente o *hook* que ajusta o relógio do sistema. No FreeRTOS, isso normalmente significa atualizar o *tick count* ou um RTC hardware.

---

### **10.3.3 Limitações do NTP**

Apesar de útil, NTP tem limitações graves para aplicações industriais:

* não considera assimetria de rede (cabos, switches, delays diferentes)
* não oferece precisão de microssegundos
* é vulnerável a jitter
* não lida bem com redes congestionadas
* sua precisão depende de latência relativamente estável

Para um controle industrial com motores coordenados, ou sensores que precisam marcar eventos com precisão absoluta, NTP simplesmente não é suficiente.

É aqui que surge o **PTP**.

---

### **10.3.4 PTP — Precision Time Protocol (IEEE 1588)**

PTP é a resposta moderna ao problema de sincronização precisa em redes Ethernet. Ele permite sincronização na ordem de:

* 1 microsegundo (software)
* 100–200 nanosegundos (hardware timestamping)
* <50 ns (PHY especializado)

Se NTP é um carteiro, PTP é um relógio suíço distribuído.

#### **Como PTP funciona (simplificado)**

PTP utiliza:

* **mensagens Sync**
* **mensagens Follow_Up**
* **mensagens Delay_Req / Delay_Resp**

Mas ao contrário do NTP, PTP pode utilizar **carimbos de tempo feitos pelo hardware no exato momento em que o frame atravessa o MAC/PHY**.

Isso elimina:

* jitter do sistema operacional
* latência imprevisível em filas de processamento
* variação em drivers de rede

Um exemplo de timestamping feito pelo MAC em muitos microcontroladores STM32:

```
ETH->PTPTSHR   // seconds high
ETH->PTPTSLR   // seconds low
ETH->PTPTSR    // sub-second resolution (~ns)
```

---

### **10.3.5 PTP com timestamping por hardware**

Quando o hardware suporta IEEE1588, o processo é:

1. Um frame PTP chega.
2. O MAC gera automaticamente um timestamp exato.
3. O driver entrega à pilha PTP o tempo capturado.
4. A pilha ajusta o relógio local usando PLL ou correção de offset.

#### Exemplo simplificado de driver MAC para timestamping (STM32)

```c
void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth) {
    ETH_BufferTypeDef *rx = heth->RxDescList.RxDesc;

    if (rx->TimestampAvailable) {
        uint32_t seconds = rx->TimeStamp.TimeStampHigh;
        uint32_t nanos   = rx->TimeStamp.TimeStampLow;
        ptp_handle_rx_timestamp(seconds, nanos);
    }

    ethernet_input(rx->buffer);
}
```

Aqui, `TimestampAvailable` e os campos associados são preenchidos **pelo próprio hardware**.

---

### **10.3.6 PTP com timestamping por software**

Quando o hardware não coopera, ainda é possível fazer PTP — mas com precisão bem inferior:

```c
uint64_t ptp_soft_timestamp(void) {
    return get_system_time_ns();  // obtém nanosegundos estimados
}
```

O desvio tende a ser significativo, mas ainda pode alcançar precisão de microsegundos em redes estáveis.

---

### **10.3.7 Aplicações reais de NTP e PTP**

#### Onde NTP é suficiente:

* IoT residencial
* relógios de sensores de baixa exigência
* sincronização de logs
* telemetria
* dispositivos alimentados por bateria onde simplicidade importa

#### Onde PTP é obrigatório:

* robótica colaborativa (cobots)
* motion control industrial
* sincronização de motores
* aquisição distribuída de sinais (DAQ)
* radares
* automobilística moderna (TSN, AVB)
* equipamentos médicos de alta precisão

---

### **10.3.8 Integração com FreeRTOS, Zephyr e LWIP**

* **FreeRTOS**: não possui suporte a PTP internamente; depende de bibliotecas externas
* **Zephyr**: oferece uma implementação PTP bastante robusta, incluindo timestamping
* **LWIP**: possui suporte NTP, mas PTP geralmente é integrado via módulos externos (ex.: ptpd, gPTP)

Em aplicações profissionais, a escolha da pilha PTP deve considerar:

* suporte a hardware timestamping
* capacidade de configurar clocks servo
* integração com drivers MAC do MCU
* certificações (automotiva, industrial)


## **10.4 Comunicação sem fio (BLE, Wi-Fi, ZigBee, LoRa)**

*“Ah, a comunicação sem fio… esse prodígio que faz os engenheiros sorrirem e arrancarem os cabelos em igual proporção.”*
— **Tanenbaum (provavelmente diria algo assim)**

Se a comunicação com fio já exige disciplina — bits alinhados, ruído controlado, interferência minimizada — a comunicação **sem fio** exige tudo isso *e mais o imprevisível*: desvanecimento, multipercurso, ruído eletromagnético, micro-ondas do vizinho, e aquela parede de concreto armado que parece alimentada por um demônio que odeia RF.

Apesar de suas adversidades, o sem fio tornou-se indispensável: sensores IoT, dispositivos móveis, redes industriais e até válvulas hidráulicas em planta petroquímica hoje falam pelo ar. E, como costuma acontecer na engenharia, cada protocolo mirou um compromisso diferente entre **alcance**, **energia**, **taxa de dados** e **complexidade da pilha**.

Para sistemas embarcados, conhecer essas características é vital — tanto para escolher o protocolo adequado quanto para depurar aquele pacote que simplesmente *desaparece no éter*.

Vamos aos protagonistas.

---

## **10.4.1 BLE — Bluetooth Low Energy**

Se fosse uma pessoa, o **BLE** seria o sujeito magro, econômico, que come pouco e funciona com uma bateria de moeda por anos. Ele foi projetado para consumo ultrabaixo, não para throughput.

#### Características principais

* **Alcance típico**: 10–30 m (pode chegar a 100 m em BLE 5.x com PHYs mais lentos).
* **Taxa de dados**:

  * BLE 4.x: cerca de 1 Mbps bruto
  * BLE 5.x: até 2 Mbps (ou mais alcance a 125/500 kbps)
* **Topologia**: estrela (periférico ↔ central).
* **Aplicações típicas**: sensores, wearables, teclados, beacons, IoT “de bolso”.

#### Pilha simplificada

A pilha BLE, como toda pilha que se preze, pode ser empacotada assim:

* **PHY / Link Layer** (rádio, hopping, pacotes LL)
* **L2CAP** (multiplexação e MTU)
* **ATT / GATT** (modelo de atributos)
* **Perfis** (heart rate, HID, etc.)

É como se o BLE dissesse: “Aqui estão algumas características (Characteristics) expostas em uma tabela ordenada; peça o que quiser”.

#### Exemplo prático: leitura de characteristic

Um trecho de código em C usando **BlueZ** no Linux para ler uma characteristic GATT:

```c
// Exemplo simplificado — BlueZ DBus API
static void read_gatt_char(const char *dev_path, const char *char_uuid) {
    GDBusConnection *conn = get_dbus_connection();
    GDBusProxy *char_proxy = find_gatt_characteristic(conn, dev_path, char_uuid);

    GVariant *result = g_dbus_proxy_call_sync(
        char_proxy,
        "ReadValue",
        g_variant_new("(a{sv})", NULL),
        G_DBUS_CALL_FLAGS_NONE,
        -1,
        NULL, NULL);

    if (result) {
        GVariant *value;
        g_variant_get(result, "(@ay)", &value);
        gsize n;
        const guint8 *data = g_variant_get_fixed_array(value, &n, sizeof(guint8));

        printf("BLE value (%zu bytes): ", n);
        for (gsize i = 0; i < n; i++) printf("%02X ", data[i]);
        printf("\n");

        g_variant_unref(result);
    }
}
```

É mais burocrático que conversar com o GATT diretamente, mas mostra bem o estilo “Linux sendo Linux”.

---

### **10.4.2 Wi-Fi — O titã faminto por energia**

Se BLE é o magrinho, **Wi-Fi é o fisiculturista**: rápido, forte e permanentemente com fome — especialmente fome de energia.

#### Características principais

* **Alcance típico**: 30–50 m indoor.
* **Taxas de dados**:

  * 802.11n: 150–600 Mbps
  * 802.11ac/ax: vários Gbps
* **Consumo**: muito maior que BLE (ordens de grandeza).
* **Aplicações**: sistemas com **alto throughput**, câmeras, gateways IoT, dispositivos alimentados da rede.

Wi-Fi é excelente para streaming de vídeo ou captura massiva de dados, mas péssimo para sensores a bateria.

#### Exemplo prático: inicialização de Wi-Fi em ESP32

Um fragmento clássico para quem já programou ESP-IDF:

```c
void wifi_init_sta(void)
{
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);

    wifi_config_t wifi_config = {
        .sta = {
            .ssid = "MeuAP",
            .password = "senha1234",
        },
    };

    esp_wifi_set_mode(WIFI_MODE_STA);
    esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config);
    esp_wifi_start();
}
```

Simples, direto — e, se você medir a corrente no osciloscópio, descobrirá que esse código transformou seu MCU em um equipamento “de porte médio”.

---

### **10.4.3 ZigBee — O diplomata das redes mesh**

Se BLE é o modesto e Wi-Fi é o exagerado, **ZigBee** é o diplomata que tenta fazer todos conversarem; sua especialidade é formar redes **mesh** grandes e auto-organizáveis.

#### Características

* **Padrão**: IEEE 802.15.4
* **Taxa de dados**: 250 kbps
* **Alcance**: 10–100 m por nó
* **Topologia**: estrela, árvore ou mesh
* **Aplicações**: automação residencial, sensores distribuídos, IoT escalável.

Ao contrário de BLE e Wi-Fi, o ZigBee brilha quando se trata de grandes redes com dezenas ou centenas de nós, onde cada nó pode atuar como roteador.

#### Pilha simplificada

* **PHY/MAC** (802.15.4)
* **NWK** (roteamento mesh)
* **APS**
* **ZCL** (ZigBee Cluster Library)
* **Perfis de aplicação** (Home Automation, Light Link etc.)

#### Exemplo conceitual de envio de frame 802.15.4

```c
// Exemplo genérico para radios 802.15.4
void send_frame(uint8_t *payload, uint8_t len) {
    radio_write_register(TX_FIFO, payload, len);
    radio_cmd(STROBE_TX);   // inicia a transmissão
    while (!radio_flag(TX_DONE))
        ; // busy wait (ruim, mas ilustrativo)
}
```

Em implementações reais, interrupções e buffers circulares assumem o controle — mas a essência permanece.

---

### **10.4.4 LoRa — O eremita de longo alcance**

**LoRa** vive afastado dos outros, nas montanhas, enviando mensagens lentas porém extremamente distantes. É o mestre zen da comunicação de longo alcance e baixíssimo consumo.

#### Características

* **Alcance**: quilômetros (2–15 km dependendo da região)
* **Taxa de dados**: 0.3–50 kbps
* **Topologia**: estrela (LoRaWAN) ou ponto a ponto
* **Aplicações**: agricultura, cidades inteligentes, telemetria remota, sensores em áreas rurais.

Sua grande arma é a modulação **CSS (Chirp Spread Spectrum)**, que sacrifica throughput e latência para ganhar **sensibilidade absurda**. Em certas configurações, um receptor LoRa consegue ouvir sinais que praticamente desaparecem no ruído térmico.

#### Um envio LoRa usando SX1276 (pseudo-C)

```c
void lora_send(const uint8_t *data, uint8_t len)
{
    lora_set_mode(STDBY);
    lora_write_fifo(data, len);

    // arg: modo de operação = TX
    lora_write_reg(REG_OP_MODE, MODE_LORA_TX);

    while (!(lora_read_reg(REG_IRQ_FLAGS) & IRQ_TX_DONE))
        ;

    // limpa IRQ
    lora_write_reg(REG_IRQ_FLAGS, IRQ_TX_DONE);
}
```

LoRa é simples na superfície, mas profundamente configurável — espalhamento, taxa de código, largura de banda e potência precisam ser harmonizados com precisão.

---

### **10.4.5 Fazendo escolhas: o eterno compromisso**

Se há um mantra universal em sistemas embarcados é o seguinte:

> **Não existe um protocolo “melhor”, apenas aquele que encaixa no seu compromisso de energia, alcance e taxa.**

Uma tabela comparativa ajuda:

| Tecnologia | Energia     | Alcance     | Throughput  | Topologia | Aplicações típicas    |
| ---------- | ----------- | ----------- | ----------- | --------- | --------------------- |
| **BLE**    | muito baixa | curta       | baixa-média | estrela   | sensores, wearables   |
| **Wi-Fi**  | alta        | média       | alta        | estrela   | câmeras, gateways     |
| **ZigBee** | baixa       | média       | baixa       | mesh      | automação residencial |
| **LoRa**   | muito baixa | muito longa | muito baixa | estrela   | telemetria remota     |


## **10.5 Integração entre camadas física, enlace e aplicação**

*(onde finalmente admitimos que, embora as camadas sejam lindas no papel, na prática elas se misturam como espaguete no prato)*

Andrew Tanenbaum sempre gostou da ideia de **camadas bem definidas** — estruturas conceituais que isolam preocupações e trazem ordem ao caos do mundo real. Mas, como qualquer engenheiro embarcado sabe, no fundo de um microcontrolador as coisas dificilmente permanecem tão arrumadas assim.

A borda entre a camada física e a camada de enlace frequentemente é apenas um conjunto de registradores mal-humorados; a interface entre a camada de aplicação e a lógica de rede, por sua vez, frequentemente envolve filas e interrupções que acordam tarefas em horários inconvenientes.

Ainda assim, vale a pena entender como integrar essas partes. Quando bem feito, um sistema embarcado de comunicação torna-se **responsivo, robusto e previsível**. Quando mal feito… bem, vira um daqueles rádios que “funcionam só quando estão de bom humor”.

Vamos estabelecer uma visão clara — ainda que generosamente verbosa — dessa integração.

---

### **10.5.1 O papel da camada física: o reino dos elétrons e ondas**

A camada física é a mais honesta de todas: ela não promete nada além de **transmitir e receber sinais**. É aqui que vivem:

* níveis de tensão (UART)
* polaridades e clock compartilhado (SPI)
* estados de linha e condutores abertos (I²C)
* modulações (QPSK, GFSK, OFDM, CSS)
* potência do transmissor
* antenas e impedância

No MCU, essa camada é tipicamente acessada por registradores que expõem:

* status do periférico: `TXE`, `RXNE`, `BUSY`, `OVERRUN`
* controladores de clock e baud rate
* configuração de pinos: GPIO, AF (alternate functions)

#### Exemplo (ARM Cortex-M, registro de status UART):

```c
if (USART1->ISR & USART_ISR_RXNE) {
    uint8_t byte = USART1->RDR;  // Leitura limpa a flag RXNE
}
```

Aqui, não há protocolo complexo: apenas bits vindo do mundo físico, empurrados para dentro do microcontrolador pelo hardware.

---

### **10.5.2 A camada de enlace: transformando sinais em significado**

A camada física entrega bytes crus; a camada de enlace (link layer) transforma isso em algo minimamente utilizável:

* detecção de erro (CRC, FEC)
* framing (start/stop bits, delimitadores, preâmbulos)
* retransmissões
* endereçamento local
* controle de acesso ao meio (CSMA/CA em Wi-Fi, backoff, acknowledgments)
* ordenação de pacotes (às vezes)

O enlace é o primeiro ponto em que o mundo começa a fazer algum sentido.

#### Exemplo: framing simples com delimitadores

Imagine um protocolo próprio via UART:

```
0x7E | LENGTH | DATA... | CRC16 | 0x7E
```

Em C:

```c
#define FRAME_DELIM 0x7E

void process_uart_input(uint8_t b)
{
    static uint8_t buffer[256];
    static size_t idx = 0;
    static bool in_frame = false;

    if (b == FRAME_DELIM) {
        if (in_frame && idx > 2) {
            handle_frame(buffer, idx);
        }
        idx = 0;
        in_frame = true;
        return;
    }

    if (in_frame && idx < sizeof(buffer)) {
        buffer[idx++] = b;
    }
}
```

Repare como a camada de enlace já “domesticou” o fluxo contínuo de bytes.

---

### **10.5.3 A camada de transporte e rede: quando a aplicação quer garantias**

Numa pilha como TCP/IP ou mesmo BLE (GATT/ATT), temos mecanismos que lidam com:

* confiabilidade (ACK, retransmissões)
* controle de fluxo
* fragmentação
* multiplexação de conexões (portas TCP, handles ATT)

Na integração embarcada, essas camadas frequentemente rodam em software e estão intimamente ligadas ao RTOS.

#### Exemplo: pilha TCP/IP leve como LWIP

LWIP assume que você tem:

* interrupções de RX/TX
* buffers circulares
* funções de envio/recebimento providas pelo driver

O fluxo típico:

1. **Driver recebe frame via DMA ou IRQ**
2. **Passa para a pilha LWIP**
3. **LWIP processa IP/TCP**
4. **Entrega o payload para a aplicação (callback)**

Trecho ilustrativo:

```c
// Chamada a partir da interrupção de RX do driver Ethernet
void ethernetif_input(void *arg)
{
    struct pbuf *p = low_level_input(); // coleta frame da camada física
    if (p != NULL) {
        if (netif->input(p, netif) != ERR_OK) {
            pbuf_free(p); // descarta se a pilha não quiser
        }
    }
}
```

Aqui vemos a integração clássica entre **hardware → driver → enlace → rede → transporte → aplicação**.

---

### **10.5.4 A camada de aplicação: protocolos de verdade**

Depois de todo o trabalho duro das camadas inferiores, a aplicação finalmente recebe:

* um pacote GATT do BLE,
* uma mensagem MQTT,
* um frame CAN decodificado,
* um pacote TCP contendo um comando JSON,
* um valor modbus lido do registrador 0x1234.

É aqui que a lógica de negócio acontece, e onde estados e máquinas de estado reinam.

#### Exemplo (MQTT em um ESP32 com RTOS):

```c
void mqtt_event_handler(void *handler_args, esp_event_base_t base,
                        int32_t event_id, void *event_data)
{
    switch(event_id) {
        case MQTT_EVENT_DATA:
            printf("Recebido tópico: %s\n", event->topic);
            printf("Payload: %.*s\n", event->data_len, event->data);
            break;
    }
}
```

Aqui a aplicação já está em um nível confortável — nada de registradores mal-educados.

---

### **10.5.5 Fluxo completo: do elétron ao serviço**

Vamos traçar o caminho típico de um pacote — algo que Tanenbaum adoraria comentar com sarcasmo.

1. **Camada física**
   Os elétrons se agitam, ondas são moduladas, bits são detectados; ruído luta pelo controle.
2. **Camada de enlace**
   O pacote é identificado, verificado, checado contra CRC; o frame é reconstruído.
3. **Transporte/Rede**
   O pacote é roteado, retransmitido, reordenado, e entregue (com atraso ou amor).
4. **Aplicação**
   O conteúdo finalmente importa: comando, sensor, controle.
5. **Resposta**
   O ciclo recomeça — e a engenharia reza para que nada dê errado no caminho.

---

### **10.5.6 Integração com RTOS: onde tudo se conecta**

Em sistemas embarcados modernos, a integração é frequentemente mediada pelo RTOS:

* interrupções acordam tarefas responsáveis por cada camada;
* filas e mailboxes conduzem pacotes entre níveis;
* prioridades determinam quem processa primeiro;
* DMA remove parte da carga da CPU.

Um fluxo típico com FreeRTOS poderia ser:

```
ISR RX UART → fila_rx → tarefa_link
tarefa_link → fila_proto → tarefa_protocolo
tarefa_protocolo → evento → tarefa_aplicacao
```

Cada camada tem sua tarefa — separação e clareza (um eco distante do modelo OSI).

---

### **10.5.7 Boas práticas de integração**

1. **Buffers bem dimensionados**
   Subestimar o tamanho do buffer é receita certa para dor de cabeça.

2. **Separação clara de responsabilidades**
   Não deixe sua ISR decodificar frames inteiros — esse é trabalho de uma tarefa.

3. **Evite bloqueios em drivers**
   A abstração de camadas depende de que cada parte flua.

4. **Use DMA sempre que possível**
   Sobretudo em Wi-Fi e Ethernet (salva vidas, ciclos e paciência).

5. **Use logs com parcimônia**
   Um `printf` colocado no lugar errado pode destruir seu timing.


