# **Capítulo 10 — Comunicação entre Dispositivos**

## **10.1 Protocolos de comunicação serial (UART, SPI, I²C, CAN)**

Quando dois dispositivos desejam conversar no mundo digital, precisam antes concordar em um idioma — seu conjunto de sinais elétricos, tempos, convenções de início e fim, e até sobre quem fala primeiro. Nos computadores pessoais, esse “idioma” costuma ser abstraído por camadas e camadas de protocolos. Já em sistemas embarcados, essas convenções descem ao nível do fio de cobre.

Aqui, cada bit importa. Literalmente.

O engenheiro de sistemas embarcados precisa compreender não somente o que está sendo enviado, mas como e quando. Afinal, um microcontrolador típico conversa diariamente com sensores, atuadores, memórias, rádios, displays… e cada um usa um dialeto diferente. Nesta seção analisaremos os quatro protocolos seriais mais tradicionais: **UART, SPI, I²C e CAN**.

---

### **10.1.1 UART — o velho telefone de dois fios**

Historicamente, UART (Universal Asynchronous Receiver/Transmitter) é talvez o protocolo mais antigo e onipresente ainda em uso. Sua popularidade deriva da simplicidade: dois dispositivos, um fio para transmitir (TX), outro para receber (RX), e pronto. Nada de clock compartilhado, nada de topologias complicadas.

É como um telefone com fio, em que cada participante sabe com que velocidade o outro fala. Se ambos concordam em falar a 9600 palavras por segundo, a conversa flui. Se um fala a 115200 e outro a 4800, conversas serão dignas de um rádio mal sintonizado.

#### **Formato do quadro UART**

Um quadro UART típico pode ser ilustrado assim:

```
Start | Data bits | Parity | Stop
  0   |   8 bits  | opcional | 1 ou 2 bits em 1
```

A borda de descida do bit de start anuncia que uma palavra está chegando. A partir daí, o receptor assume que o transmissor manterá o timing perfeitamente — o que, claro, pode não ocorrer, tornando UART vulnerável a jitter e drift de clock.

Apesar disso, é ideal para **debug**, **telemetria simples**, **configurações** e sensores legados.

### **Exemplo: Inicializando UART em C (bare-metal ARM Cortex-M)**

A seguir um exemplo bem resumido para STM32 (registradores reais, estilo didático):

```c
// Configura USART2 a 115200 baud, 8N1
void uart2_init(void) {
    // Habilita clock do GPIOA e USART2
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    // Configura PA2 como TX e PA3 como RX (alternate function AF7)
    GPIOA->MODER &= ~((3 << (2*2)) | (3 << (3*2)));   // limpa MODER
    GPIOA->MODER |=  ((2 << (2*2)) | (2 << (3*2)));   // modo AF
    GPIOA->AFR[0] |= (7 << 8) | (7 << 12);            // AF7

    // Configura baud rate (assumindo 16 MHz)
    USART2->BRR = 16000000 / 115200;

    // Habilita USART: TX, RX e módulo
    USART2->CR1 |= USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;
}

void uart_write(char c) {
    while (!(USART2->SR & USART_SR_TXE)); // espera buffer vazio
    USART2->DR = c;
}
```

Nada mais Tanenbaum do que manipular registradores e explicar que “um simples bit configurado incorretamente faz o sistema entrar em colapso”.

---

### **### 10.1.2 SPI — comunicação serial com esteroides**

Se UART é uma ligação telefônica, **SPI (Serial Peripheral Interface)** é mais parecido com um sistema de rádio militar de quatro canais, todos sincronizados por um relógio central.

Ele utiliza:

* **MOSI** — Master Out Slave In
* **MISO** — Master In Slave Out
* **SCLK** — Clock
* **SS / CS** — Chip Select (um por escravo)

SPI é **síncrono**: o clock é fornecido pelo mestre. Com isso, é extremamente mais estável e rápido do que UART, frequentemente alcançando **dezenas de MHz**.

#### Vantagens

* Altíssima velocidade
* Comunicação full-duplex
* Protocolo simples (quase nenhum overhead)
* Ideal para displays, memórias Flash, rádios, sensores de alta velocidade

#### Desvantagens

* Requer muitos fios
* Escalabilidade ruim (muitos slaves = muitos CS)
* Topologia radial, não multi-mestre

#### Exemplo: Leitura de memória SPI Flash (pseudocódigo Linux driver)

```c
// Função simplificada de leitura de uma memória SPI NOR
int spi_flash_read(struct spi_device *spi, u32 addr, u8 *buf, size_t len) {
    u8 cmd[4];
    cmd[0] = 0x03; // READ
    cmd[1] = (addr >> 16) & 0xFF;
    cmd[2] = (addr >> 8) & 0xFF;
    cmd[3] =  addr & 0xFF;

    struct spi_transfer t[2] = {
        {.tx_buf = cmd, .len = 4},
        {.rx_buf = buf, .len = len},
    };

    return spi_sync_transfer(spi, t, 2);
}
```

Aqui vemos como o Linux realmente faz — através de `spi_transfer` estruturado — uma bela abstração sobre o caos elétrico dos fios.

---

### **10.1.3 I²C — dois fios, muitos dispositivos**

O barramento **I²C** foi criado pela Philips com uma ideia simples: *e se todos os dispositivos pudessem compartilhar apenas dois fios?* Assim nasceram SDA (dados) e SCL (clock), ambos de propósito múltiplo e drenagem aberta (open-drain).

Diferente de SPI, I²C suporta:

* múltiplos mestres
* vários escravos
* endereços de 7 ou 10 bits
* detecção de colisão (arbitragem por nível lógico)

É perfeito para sensores, RTCs, expanders de GPIO e periféricos de baixa/média velocidade.

#### O protocolo I²C é mais complexo que parece

Um frame simplificado:

```
START
ADDR (7 bits) + R/W
ACK
DATA
ACK
...
STOP
```

Tudo isso operando em faixas de até 400 kHz (Standard/Fast), ou até alguns MHz em Fast Mode Plus.

#### Exemplo: leitura de registrador em I²C (bare-metal)

```c
uint8_t i2c_read_reg(uint8_t dev, uint8_t reg) {
    i2c_start();

    i2c_write((dev << 1) | 0); // Write mode
    i2c_write(reg);

    i2c_start();               // Repeated start
    i2c_write((dev << 1) | 1); // Read mode
    uint8_t val = i2c_read_nack();

    i2c_stop();
    return val;
}
```

Notável é o famoso **repeated start**, que evita perder controle do barramento.

---

### **### 10.1.4 CAN — comunicação para ambientes hostis**

O barramento **CAN (Controller Area Network)** foi projetado para automóveis e ambientes onde falhas não são opcionais: são esperadas. Em outras palavras, o inesperado é parte do projeto.

Aqui, cada mensagem tem **ID de prioridade**, e o próprio barramento resolve contendas eletricamente. Um exemplo da elegância do CAN é que, em uma colisão, o dispositivo com ID mais prioritário automaticamente vence — sem retransmissões desnecessárias.

#### Características marcantes

* Alta imunidade a ruído
* Topologia multi-mestre
* Até ~1 Mbps no CAN clássico
* Frames com CRC, ACK explícito, bits de stuffing
* CAN FD permite quadros muito maiores e rápidos

#### Formato simplificado do frame CAN

```
SOF | Arbitration ID | Control | Data (0-8 bytes) | CRC | ACK | EOF
```

#### Exemplo: handler de interrupção de CAN em STM32 (estilo real)

```c
void CAN1_RX0_IRQHandler(void) {
    if (CAN1->RF0R & CAN_RF0R_FMP0) { // FIFO tem mensagem
        CAN_RxMsgTypeDef msg;

        msg.StdId = (CAN1->sFIFOMailBox[0].RIR >> 21) & 0x7FF;
        msg.DLC   = CAN1->sFIFOMailBox[0].RDTR & 0xF;

        for (int i = 0; i < msg.DLC; i++) {
            msg.Data[i] = (CAN1->sFIFOMailBox[0].RDLR >> (8*i)) & 0xFF;
        }

        // Processa mensagem (aplicação)
        handle_can_message(&msg);

        // Libera FIFO
        CAN1->RF0R |= CAN_RF0R_RFOM0;
    }
}
```

Observe como o hardware entrega a maior parte do trabalho pronto: IDs, DLC, buffers organizados — o programador apenas extrai e responde.


## **10.2 Protocolos de rede (Ethernet, TCP/IP, LWIP)**

A comunicação serial, como vimos, é extremamente útil quando dois dispositivos estão próximos — literalmente a centímetros de distância. Mas à medida que sistemas embarcados passaram a integrar máquinas industriais, automóveis, robôs, drones e dispositivos IoT espalhados por cidades inteiras, tornou-se evidente que “dois fios e um clock” já não eram suficientes.

Era necessário um protocolo universal. Um que permitisse conectar máquinas por metros, quilômetros ou continentes. E que sobrevivesse ao caos da comunicação real, onde pacotes se perdem, cabos quebram, e bits chegam corrompidos como palavras na chuva.

Assim surgiram **Ethernet**, **IP**, **TCP**, **UDP**, e todo o ecossistema de rede que domina o planeta.
E, nos sistemas embarcados, tudo isso é frequentemente implementado por **LWIP**, uma stack TCP/IP compacta e eficiente.

---

### **10.2.1 Ethernet — a base física e de enlace**

Ethernet é o equivalente moderno de um conjunto de cartas enviadas por mensageiros que percorrem corredores compartilhados. Há um meio físico, há colisões, há um organismo responsável por endereçar as “casas” (endereços MAC), e há regras claras de convivência.

Nas versões antigas (10BASE-T), Ethernet era como uma conversa de bar — todos falando no mesmo fio (o famoso CSMA/CD). Hoje, com switches full-duplex, a conversa é muito mais organizada: cada porta conversa apenas com o seu interlocutor.

#### Frame Ethernet (simplificado)

```
| Dest MAC | Src MAC | EtherType | Payload | CRC |
```

O campo EtherType indica o que vem depois: IPv4? ARP? IPv6?

O CRC (FCS) garante que erros sejam detectados ainda na camada 2.

#### Exemplo real: sniff de pacote com tcpdump

```
12:23:10.123456 ethertype IPv4 (0x0800), length 98:
    192.168.0.10.5000 > 192.168.0.4.1234: Flags [P.], seq 1:49, ack 1
```

Se você já fez debug de rede em um microcontrolador usando **Wireshark**, sabe o quanto isso salva vidas — e reputações.

---

### **10.2.2 TCP/IP — a pilha lógica que dá sentido aos bytes**

Quando Tanenbaum escreveu sobre redes de computadores, descreveu a pilha TCP/IP como uma “engenhoca engenhosa sobreposta a outra engenhoca”. E tinha razão.

A pilha funciona como um condomínio organizado:

* **Ethernet** entrega pacotes dentro do prédio;
* **IP** cuida de endereços entre edifícios;
* **TCP e UDP** definem como os moradores conversam entre si;
* **Aplicações** interpretam o conteúdo: HTTP, MQTT, Modbus/TCP…

#### IP: O carteiro do sistema

O protocolo IP é *não confiável*: entrega se puder, descarta se necessário. Nada de garantias.
Seu papel é rotear pacotes pelo labirinto da rede.

#### TCP: A conversa educada

TCP cria um canal confiável usando mecanismos como:

* Handshake 3-way
* Numeração de sequência
* Retransmissões e ACKs
* Controle de congestionamento

É como dois interlocutores que confirmam cada frase antes de seguir.

#### UDP: “Joga na rede e torce”

UDP é minimalista e rápido — usado para streaming, jogos, telemetria.
Se o pacote se perder, paciência.

---

### **10.2.3 LWIP — TCP/IP no microcontrolador**

LWIP (Lightweight IP), criado por Adam Dunkels, é o milagre que permite rodar TCP/IP em um microcontrolador com 64 KB de RAM sem que o sistema imploda.

Ele implementa:

* ARP
* IPv4 / IPv6
* ICMP
* UDP
* TCP
* DHCP, DNS (opcionais)

E o faz utilizando uma combinação engenhosa de:

* buffers extremamente compactos
* callbacks
* modo raw (sem sockets)
* opcionalmente BSD sockets

#### Arquitetura simplificada

```
NIC Driver <-> LWIP Low-level <-> IP/TCP/UDP <-> Application
```

#### O papel crucial do **driver Ethernet**

LWIP não fala diretamente com o hardware. Quem cuida disso é o *low-level driver*, que deve:

* Receber frames da MAC/PHY
* Entregar à função `ethernet_input()`
* Enviar pacotes usando `low_level_output()`

Uma implementação ruim do driver arruína toda a pilha — e isso acontece com frequência em projetos amadores.

---

### **10.2.4 Exemplo real: socket TCP com LWIP (modo BSD)**

Este é um código *realista*, retirado e simplificado de aplicações baseadas em FreeRTOS + LWIP:

```c
void tcp_server_task(void *arg) {
    int sock, client;
    struct sockaddr_in addr, client_addr;
    socklen_t addr_len = sizeof(client_addr);

    sock = lwip_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = INADDR_ANY;

    lwip_bind(sock, (struct sockaddr *)&addr, sizeof(addr));
    lwip_listen(sock, 2);

    while (1) {
        client = lwip_accept(sock, (struct sockaddr *)&client_addr, &addr_len);
        lwip_write(client, "Hello from MCU!\n", 17);
        lwip_close(client);
    }
}
```

A beleza disto?
Um microcontrolador de poucos megahertz, muitas vezes sem MMU, está agindo como um servidor de rede.

---

### **10.2.5 Exemplo raw API no LWIP (sem sockets)**

A versão raw exige mais cuidado, mas consome muito menos RAM:

```c
// Callback quando dados chegam
err_t tcp_recv_callback(void *arg, struct tcp_pcb *tpcb,
                        struct pbuf *p, err_t err) {

    if (p == NULL) {
        tcp_close(tpcb);
        return ERR_OK;
    }

    tcp_write(tpcb, p->payload, p->len, TCP_WRITE_FLAG_COPY);
    tcp_recved(tpcb, p->len);
    pbuf_free(p);

    return ERR_OK;
}

void tcp_init_server(void) {
    struct tcp_pcb *pcb = tcp_new();
    tcp_bind(pcb, IP_ADDR_ANY, 8888);

    pcb = tcp_listen(pcb);
    tcp_accept(pcb, tcp_accept_callback);
}
```

O programador tem controle total — e responsabilidade total.
Um erro aqui (ex.: não chamar `tcp_recved`) pode destruir o desempenho.

---

### **10.2.6 Desafios reais em redes embarcadas**

Não é por acaso que sistemas embarcados com rede são notoriamente difíceis:

* **latência de interrupção** aumenta com tráfego intenso
* **pbuf leaks** causam esgotamento de memória
* drivers MAC mal implementados causam overruns
* o PHY pode entrar em estados estranhos devido a ruído ou quedas de energia
* ARP cache pode se tornar inconsistente
* DHCP pode falhar em condições de congestão
* TCP, por si só, pode consumir dezenas de kilobytes de RAM

Todo projeto Ethernet embarcado precisa lidar com diagnósticos: counters, estatísticas, watchdogs, dumps de pbuf, timeouts de link, e reinicialização de interface.


## **10.3 Sincronização de tempo (NTP, PTP)**

O tempo é, por si só, uma ilusão útil — mas em sistemas embarcados ele se torna um recurso técnico fundamental. Dois sensores que registram eventos sem relógios sincronizados não podem gerar correlação precisa; dois controladores industriais que acionam motores sem uma referência temporal comum podem destruir equipamentos; dois robôs que se movem sem coordenadas temporais alinhadas podem literalmente colidir.

Portanto, a sincronização de tempo surge como um requisito essencial tanto em sistemas distribuídos clássicos quanto em dispositivos embarcados modernos.

Nesta seção, faremos como Tanenbaum faria: começaremos com o problema conceitual, evoluindo para os mecanismos práticos, e finalizando com exemplos reais baseados em microcontroladores.

---

### **10.3.1 O problema da sincronização de relógios**

Imagine um sistema com três dispositivos:

* Sensor A: registra temperatura
* Sensor B: registra vibração
* Controlador C: gera alarmes quando o aumento de temperatura precede vibração em até 20 ms

Para que o alarme seja confiável, os três dispositivos precisam de um **tempo compartilhado**. Mas microcontroladores usam osciladores com drift (deriva) — alguns chegam a *30–100 ppm* de erro, o que resulta em vários milissegundos de discrepância em poucas horas.

Sem sincronização de tempo:

```
Sensor A: evento às 10:00:00.001
Sensor B: evento às 10:00:00.003
Controlador: interpreta B como ocorrendo antes de A → comportamento incorreto
```

Com sincronização:

```
Ambos usam um tempo global e consistente → análise correta
```

É aqui que entram **NTP** (preciso na ordem de milissegundos) e **PTP** (preciso na ordem de microssegundos ou até sub-microsegundos).

---

### **10.3.2 NTP — Network Time Protocol**

O NTP é o veterano do mundo da sincronização de tempo. Foi projetado na década de 1980 para computadores em redes grandes e lentas. Em sistemas embarcados modernos, ainda é amplamente utilizado — especialmente quando precisão de milissegundos é suficiente.

#### **Como funciona o NTP**

A ideia central é simples: medir *latência* e *offset* de tempo entre cliente e servidor.

Um cliente envia um pacote contendo o *timestamp local de envio*. O servidor devolve um pacote contendo:

* horário em que recebeu
* horário em que enviou

Com esses quatro tempos, o cliente estima:

* o **offset** (diferença entre relógios)
* o **delay** (latência de ida e volta)

A famosa fórmula é:

```
offset = ((t2 - t1) + (t3 - t4)) / 2
delay  = (t4 - t1) - (t3 - t2)
```

Onde:

* t1: cliente envia req
* t2: servidor recebe
* t3: servidor envia resp
* t4: cliente recebe resp

#### **Precisão típica**

* Internet: 10–100 ms
* LAN estável: 1–5 ms
* Embarcados com RTC ruim: ~10 ms devido a drift

#### **Exemplo real LWIP: sincronização NTP**

LWIP oferece um cliente NTP simples, que pode ser acionado periodicamente:

```c
#include "lwip/apps/sntp.h"

void ntp_sync_init(void) {
    sntp_setoperatingmode(SNTP_OPMODE_POLL);
    sntp_setservername(0, "pool.ntp.org");
    sntp_init();
}
```

Quando o servidor NTP responde, LWIP chama internamente o *hook* que ajusta o relógio do sistema. No FreeRTOS, isso normalmente significa atualizar o *tick count* ou um RTC hardware.

---

### **10.3.3 Limitações do NTP**

Apesar de útil, NTP tem limitações graves para aplicações industriais:

* não considera assimetria de rede (cabos, switches, delays diferentes)
* não oferece precisão de microssegundos
* é vulnerável a jitter
* não lida bem com redes congestionadas
* sua precisão depende de latência relativamente estável

Para um controle industrial com motores coordenados, ou sensores que precisam marcar eventos com precisão absoluta, NTP simplesmente não é suficiente.

É aqui que surge o **PTP**.

---

### **10.3.4 PTP — Precision Time Protocol (IEEE 1588)**

PTP é a resposta moderna ao problema de sincronização precisa em redes Ethernet. Ele permite sincronização na ordem de:

* 1 microsegundo (software)
* 100–200 nanosegundos (hardware timestamping)
* <50 ns (PHY especializado)

Se NTP é um carteiro, PTP é um relógio suíço distribuído.

#### **Como PTP funciona (simplificado)**

PTP utiliza:

* **mensagens Sync**
* **mensagens Follow_Up**
* **mensagens Delay_Req / Delay_Resp**

Mas ao contrário do NTP, PTP pode utilizar **carimbos de tempo feitos pelo hardware no exato momento em que o frame atravessa o MAC/PHY**.

Isso elimina:

* jitter do sistema operacional
* latência imprevisível em filas de processamento
* variação em drivers de rede

Um exemplo de timestamping feito pelo MAC em muitos microcontroladores STM32:

```
ETH->PTPTSHR   // seconds high
ETH->PTPTSLR   // seconds low
ETH->PTPTSR    // sub-second resolution (~ns)
```

---

### **10.3.5 PTP com timestamping por hardware**

Quando o hardware suporta IEEE1588, o processo é:

1. Um frame PTP chega.
2. O MAC gera automaticamente um timestamp exato.
3. O driver entrega à pilha PTP o tempo capturado.
4. A pilha ajusta o relógio local usando PLL ou correção de offset.

#### Exemplo simplificado de driver MAC para timestamping (STM32)

```c
void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth) {
    ETH_BufferTypeDef *rx = heth->RxDescList.RxDesc;

    if (rx->TimestampAvailable) {
        uint32_t seconds = rx->TimeStamp.TimeStampHigh;
        uint32_t nanos   = rx->TimeStamp.TimeStampLow;
        ptp_handle_rx_timestamp(seconds, nanos);
    }

    ethernet_input(rx->buffer);
}
```

Aqui, `TimestampAvailable` e os campos associados são preenchidos **pelo próprio hardware**.

---

### **10.3.6 PTP com timestamping por software**

Quando o hardware não coopera, ainda é possível fazer PTP — mas com precisão bem inferior:

```c
uint64_t ptp_soft_timestamp(void) {
    return get_system_time_ns();  // obtém nanosegundos estimados
}
```

O desvio tende a ser significativo, mas ainda pode alcançar precisão de microsegundos em redes estáveis.

---

### **10.3.7 Aplicações reais de NTP e PTP**

#### Onde NTP é suficiente:

* IoT residencial
* relógios de sensores de baixa exigência
* sincronização de logs
* telemetria
* dispositivos alimentados por bateria onde simplicidade importa

#### Onde PTP é obrigatório:

* robótica colaborativa (cobots)
* motion control industrial
* sincronização de motores
* aquisição distribuída de sinais (DAQ)
* radares
* automobilística moderna (TSN, AVB)
* equipamentos médicos de alta precisão

---

### **10.3.8 Integração com FreeRTOS, Zephyr e LWIP**

* **FreeRTOS**: não possui suporte a PTP internamente; depende de bibliotecas externas
* **Zephyr**: oferece uma implementação PTP bastante robusta, incluindo timestamping
* **LWIP**: possui suporte NTP, mas PTP geralmente é integrado via módulos externos (ex.: ptpd, gPTP)

Em aplicações profissionais, a escolha da pilha PTP deve considerar:

* suporte a hardware timestamping
* capacidade de configurar clocks servo
* integração com drivers MAC do MCU
* certificações (automotiva, industrial)

