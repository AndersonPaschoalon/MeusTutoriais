# **Capítulo 13 — Desenvolvimento de Firmware**

*(Tanenbaum certamente diria que “firmware é software que tomou a decisão infeliz de morar dentro de um chip”)*

Neste capítulo, reunimos tudo que discutimos até agora — memória, drivers, IPC, segurança — e focamos na prática de construir firmware real. A intenção aqui é mostrar não apenas *o que* se faz, mas *como* organizar projetos de forma limpa e sustentável, evitando o famoso “grude eletrônico” que assombra a maior parte dos sistemas embarcados iniciantes.

Se necessário dividiremos em uma segunda janela, mas tentarei maximizar conteúdo sem sacrificar clareza.

---

## **13.1 Estrutura típica de um projeto embarcado**

Um projeto de firmware profissional raramente é apenas um monte de arquivos `.c` jogados em uma pasta.
Ele tem uma estrutura pensada, modular e clara, quase sempre seguindo o padrão:

```
project/
├── src/
│   ├── main.c
│   ├── drivers/
│   ├── bsp/            ← Board Support Package
│   ├── freertos/       ← ou outro RTOS
│   ├── middleware/
│   └── app/
├── include/
├── linker/
│   └── stm32f407.ld
├── scripts/
├── build/
└── Makefile / CMakeLists.txt
```

#### **Componentes essenciais**

* **main.c**: ponto inicial do firmware, costuma iniciar clocks, periféricos, RTOS etc.
* **drivers/**: drivers de baixo nível, próximos ao hardware.
* **bsp/**: abstração da placa (LEDs, botões, mapeamento de pinos).
* **middleware/**: pilhas como FATFS, LWIP, USB.
* **app/**: lógica da aplicação.
* **include/**: cabeçalhos globais.
* **linker/**: scripts de link com mapeamento da memória.
* **scripts/**: ferramentas para gerar imagem, assinar firmware, empacotar OTA.

Tanenbaum diria aqui:

> “Na ausência de uma boa estrutura, todo projeto embarcado eventualmente converge para um firmware monolítico e triste.”

---

## **13.2 Compilação, Linkagem e Geração de Imagem**

O processo de construção do firmware é mais elaborado que o de um programa desktop.
Envolve três etapas rígidas:

1. **Compilação**: cada `.c` vira `.o`
2. **Linkagem**: o *linker* monta o executável final
3. **Geração da imagem final**: ELF → BIN/HEX → assinatura, CRC etc.

#### **Comando típico com GCC para Cortex-M**

```bash
arm-none-eabi-gcc -c main.c -mcpu=cortex-m4 -mthumb -O2 -o main.o
```

#### **Linkagem com script específico**

```bash
arm-none-eabi-gcc main.o drivers/*.o \
  -T linker/stm32f407.ld \
  -o firmware.elf
```

#### **Gerar imagem binária**

```bash
arm-none-eabi-objcopy -O binary firmware.elf firmware.bin
```

---

### **13.2.1 O papel crítico do script de link (linker script)**

O linker script define *exatamente* onde cada parte do firmware será colocada na memória.

Exemplo mínimo:

```ld
MEMORY
{
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K
  RAM   (rwx): ORIGIN = 0x20000000, LENGTH = 128K
}

SECTIONS
{
  .text : {
     *(.isr_vector)
     *(.text*)
     *(.rodata*)
  } > FLASH

  .data : {
     *(.data*)
  } > RAM AT > FLASH

  .bss : {
     *(.bss*)
     *(COMMON)
  } > RAM
}
```

Logo compreenderemos melhor `.text`, `.bss`, `.data`…

---

## **13.3 Bootloader e Atualização OTA**

O bootloader é um mini-programa que roda *antes* do firmware principal.
Ele prepara o ambiente, valida a imagem e decide o que carregar.

Tanenbaum provavelmente compararia o bootloader a um “porteiro paranóico que verifica autenticidade antes de liberar a entrada”.

### **13.3.1 Funções típicas de um bootloader**

* inicialização mínima de clock e memória;
* checagem de assinatura digital ou CRC do firmware;
* suporte a “recovery mode” caso o firmware esteja corrompido;
* suporte a updates via:

  * serial (UART)
  * USB DFU
  * SD card
  * Wi-Fi/BLE
  * Ethernet (TFTP ou HTTP)
* jump seguro para a aplicação.

#### **Exemplo de salto para a aplicação (ARM Cortex-M)**

```c
typedef void (*app_entry_t)(void);

void jump_to_app(uint32_t app_addr) {
    uint32_t sp  = *(uint32_t *)(app_addr + 0);
    uint32_t pc  = *(uint32_t *)(app_addr + 4);

    __disable_irq();

    asm volatile("msr msp, %0" :: "r" (sp));  // ajusta stack pointer

    app_entry_t app_entry = (app_entry_t)pc;
    app_entry();
}
```

---

## **13.3.2 OTA — Over-The-Air Updates**

Em sistemas conectados, atualizar firmware remotamente é obrigatório.

#### **Fluxo típico OTA**

1. dispositivo baixa firmware novo (HTTP/HTTPS, MQTT, BLE, LoRaWAN).
2. grava em partição secundária ou área temporária.
3. valida assinatura digital e/ou CRC.
4. marca versão como “pendente”.
5. reinicia.
6. bootloader verifica nova imagem.
7. executa.
8. se falhar, reverte para versão anterior.

Sistemas OTA bons sempre têm **fail-safe**.

---

## **13.4 Organização de memória e seções (.text, .bss, .data)**

Essas três seções são parte fundamental da linkagem.

#### **.text**

Código executável + constantes *readonly*.
Sempre mora na flash.

#### **.data**

Variáveis inicializadas, ex.:

```c
int counter = 42;
```

Mora na RAM **mas é carregada da flash no boot**, por isso a seção aparece como:

```
.data > RAM AT > FLASH
```

#### **.bss**

Variáveis **não inicializadas**, recebem zero no boot.

```c
int sensor_buffer[128];
```

Isso evita ocupar espaço na flash com longas sequências de zeros.

#### **Código de inicialização típico no startup (simplificado)**

```c
extern uint32_t _sidata, _sdata, _edata;
extern uint32_t _sbss, _ebss;

void reset_handler(void) {
    // Copia .data da Flash para a RAM
    uint32_t *src = &_sidata;
    uint32_t *dst = &_sdata;
    while (dst < &_edata) *dst++ = *src++;

    // Zera .bss
    for (dst = &_sbss; dst < &_ebss; dst++) *dst = 0;

    main();
}
```

Isso roda antes da `main()` em praticamente todos os MCUs.

---

## **13.5 Testes e Depuração (debug serial, JTAG, SWD)**

Desenvolver firmware sem ferramentas de debug é como tentar consertar um relógio usando luvas de boxe.

### **13.5.1 Debug Serial (printf debugging)**

A ferramenta mais clássica do mundo embarcado.

Exemplo com UART em STM32:

```c
void uart_putc(char c) {
    while (!(USART2->SR & (1 << 7))); // TXE
    USART2->DR = c;
}

int _write(int file, char *ptr, int len) {
    for (int i = 0; i < len; i++)
        uart_putc(ptr[i]);
    return len;
}
```

Depois disso:

```c
printf("Temperatura: %d\n", temp);
```

Funciona — e Tanenbaum diria que esse método “é primitivo, mas incrivelmente eficaz”.

---

### **13.5.2 JTAG e SWD**

Ferramentas de debug a nível de CPU:

* breakpoints reais (hardware);
* inspeção de registradores e RAM;
* flash programming;
* visualização de periféricos.

#### **Comando clássico com OpenOCD**

```bash
openocd -f interface/stlink.cfg -f target/stm32f4x.cfg
```

#### **Debug com GDB**

```bash
arm-none-eabi-gdb firmware.elf
(gdb) target remote :3333
(gdb) monitor reset halt
(gdb) load
```

---

### **13.5.3 Testes automatizados**

Testes embarcados podem incluir:

* testes de unidade (compilados nativamente);
* testes de integração no hardware (via script);
* testes de comunicação (UART, CAN, Ethernet);
* testes de carga/estresse;
* ferramentas como Ceedling (Unity + CMock).

Mesmo que não haja um “pytest” da vida, existem pipelines sólidos:

```
host-unit-tests → build firmware → flash via SWD → testes automatizados → relatório
```


