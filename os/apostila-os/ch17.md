# **17. Sistemas Embarcados Avançados**

Ao longo das últimas décadas, os sistemas embarcados deixaram de ser pequenos dispositivos isolados — cronômetros digitais, controladores de motor ou termostatos — e se tornaram **plataformas distribuídas, conectadas, com requisitos de desempenho comparáveis aos de sistemas gerais**. Hoje, uma unidade de processamento embarcada pode controlar uma linha industrial inteira, alimentar algoritmos de visão computacional ou rodar contêineres Linux com isolamento de processos.

Este capítulo apresenta um panorama dos sistemas embarcados modernos, destacando tecnologias que antes pertenciam ao domínio dos servidores e agora aparecem em dispositivos tão pequenos quanto um módulo SOM de 2 cm².

---

## **17.1 Sistemas Multicore e SMP em Tempo Real**

#### **A Era do Multicore no Mundo Embarcado**

Durante muitos anos, o microcontrolador típico era monocore, com um pipeline simples e barramentos previsíveis. Com a demanda por mais processamento, especialmente em aplicações de comunicação (Wi-Fi, BLE, LTE), multimídia e controle avançado, surgiram plataformas multicore em dois modelos:

* **AMP (Asymmetric Multiprocessing)**
* **SMP (Symmetric Multiprocessing)**

Cada modelo traz profundas implicações para real-time, segurança e arquitetura.

---

#### **AMP — Quando Cada Núcleo Vive a Própria Vida**

O modelo AMP é historicamente o mais comum em embarcados avançados, especialmente em SoCs ARM. Aqui, **cada núcleo executa seu próprio sistema operacional** (ou firmware), com **memórias separadas** ou parcialmente compartilhadas.

Um exemplo clássico:

* **Cortex-M7** executa o controle crítico em tempo real (motor, sensores, safety).
* **Cortex-A53** roda Linux, comunicação, UI, rede.

É quase como ter dois computadores dentro do mesmo silício.

#### Vantagens do AMP:

* Previsibilidade para o núcleo de tempo real.
* Falhas no Linux não derrubam o núcleo crítico.
* Permite dividir responsabilidades de forma natural.

#### Desvantagens:

* Comunicação inter-core mais complexa (mailboxes, RPMsg, shared memory).
* Dificuldade de balancear carga.
* Maior trabalho de design e teste.

---

#### **SMP — Quando Todos os Núcleos Enxergam o Mesmo Sistema**

No modelo SMP, um único kernel administra todos os núcleos.
No Linux embarcado isso é padrão: vários Cortex-A sob o mesmo agendador.

Aqui surgem problemas que raramente apareciam em firmwares monocore:

#### 1. **Afinidade de CPU**

O kernel pode migrar threads entre núcleos para balancear carga.
Isso é bom para throughput, mas horrível para tarefas com deadlines.

É comum fixar tarefas críticas com **CPU affinity** (isolcpus).

#### 2. **Caches e Coerência**

A disciplina de coerência (MESI, MOESI) introduz atrasos imprevisíveis.
No monocore, um acesso à RAM era sempre… um acesso à RAM. No multicore, qualquer escrita pode provocar **invalidações, snoops e arbitragens**.

Isso complica a vida de quem precisa de **temporalidade garantida**.

#### 3. **Interferências de barramento**

Vários núcleos disputam:

* memória
* periféricos mapeados
* DMA
* barramento AXI

O resultado é que latências podem variar significativamente.

---

### **17.1.1 Real-Time em Sistemas SMP**

A pergunta que os engenheiros fazem é:
**“É possível ter hard real-time em SMP?”**

A resposta honesta é: **sim, mas com muita disciplina de engenharia**.
Alguns princípios gerais:

1. **Isolamento de núcleo**: reservar um core apenas para tarefas de controle.
2. **Desabilitar troca de contexto nesse núcleo** (no Linux-RT é possível).
3. Utilizar **memórias locais** e evitar regiões fortemente concorridas.
4. Dedicar **DMA channels exclusivos** para o núcleo crítico.
5. Usar protocolos de bloqueio sem preempção, como **spinlocks** rápidos.

Em alguns ambientes, regulações industriais impedem SMP por completo: o determinismo não pode depender de algoritmos de coerência de cache.

---

## **17.2 Sistemas Embarcados com Linux (Yocto, Buildroot)**

À medida que aplicações ficam mais complexas — conectividade constante, arquivos, UI, redes criptografadas — torna-se inviável usar um RTOS. É aqui que entra o **Linux embarcado**, com duas ferramentas predominantes:

* **Buildroot**
* **Yocto Project**

Ambos geram sistemas Linux minimalistas e customizados, mas com focos distintos.

---

### **17.2.1 Buildroot — Simples, Direto, Determinístico**

Buildroot gera uma imagem Linux funcional com:

* toolchain
* bootloader (u-boot)
* rootfs
* kernel
* pacotes extras

Seu ponto forte é a **simplicidade**:
um conjunto de arquivos `defconfig` e pronto.

Ele é preferido quando:

* há um único hardware alvo
* a equipe é pequena
* o produto não exige customização de metadados
* velocidade é importante

---

#### **17.2.2 Yocto — O Linux da Escala Industrial**

Yocto é muito mais poderoso — e muito mais complexo.

O que ele permite é quase “construir uma distribuição Linux do zero”, com controle absoluto de:

* versões
* bibliotecas
* layout de filesystem
* política de atualização (OSTree, SWUpdate)
* camadas de fornecedor (BSP layers)

A arquitetura é baseada em **camadas**, e isso o torna especialmente útil para cenários industriais, automotivos e IoT regulada.

#### Quando usar Yocto?

* Quando há **vários modelos de hardware**.
* Quando o produto terá **ciclo de vida longo**.
* Quando precisa de **metadados reprodutíveis**.
* Quando fornecedores exigem integração via *layers* (NXP, TI, ST).

---

### **17.2.3 Kernel Embarcado: Determinismo e Latências**

Usar Linux em sistemas embarcados exige encarar um fato:

> O Linux padrão NÃO é determinístico. Não importa o quão rápido seja.

Por isso existe o **PREEMPT_RT**, um patch que:

* transforma seções críticas em mutexes RT
* reduz latências de interrupção
* permite prioridades aninhadas
* converte spinlocks em locks preemptíveis

Com isso, o Linux atinge latências de centenas de microssegundos — o que é suficiente para controle industrial suave, mas nunca para um servodrive de alta frequência.

---

## **17.3 Virtualização e Contêineres Embarcados**

A virtualização, antes exclusiva de servidores, agora aparece até em gateways IoT.

Mas o que significa “virtualização embarcada”?

Há três modalidades principais:

---

### **17.3.1 Virtualização “Pesada”: Hypervisors Type-1**

Exemplos:

* **Xen**
* **Jailhouse** (muito popular em automotivo)
* **Acrn**

Aqui, a CPU é realmente dividida em partições, cada uma com seu próprio ambiente isolado. Em automotivo é comum ver algo como:

* **Domínio operacional (Linux)**
* **Domínio crítico (RTOS)**
* **Domínio de conectividade (Android Automotive)**

É uma forma de **segregar riscos**, garantindo que uma falha na UI não afete o controle crítico do veículo.

---

### **17.3.2 Virtualização “Leve”: Contêineres**

Surge então a pergunta:
**Docker roda em sistemas embarcados?**

Sim — mas raramente é recomendado.
Versões reduzidas, como:

* **Podman**
* **Balena Engine**
* **LXC/LXD**

são muito mais comuns.

Aqui, o objetivo não é particionar a CPU, mas sim **isolar aplicações**, facilitar deploy e permitir pipelines de CI/CD semelhantes aos de servidores.

Por exemplo, um gateway industrial pode rodar:

* um contêiner com módulo de telemetria
* outro com algoritmo de compressão
* outro com agente de atualização OTA

Tudo isso sem queimar a ROM a cada atualização.

---

### **17.3.3 Virtualização por Hardware: TrustZone**

Por fim, existe uma forma híbrida, típica em SoCs ARM:

* o *Secure World* (onde roda o firmware crítico)
* o *Normal World* (onde roda o Linux ou Android)

Isso não é virtualização no sentido clássico, mas sim uma **compartimentalização de hardware**, importantíssima em produtos conectados.

A TrustZone é frequentemente usada para:

* proteger chaves criptográficas
* validar firmware
* implementar boot seguro
* isolar serviços de segurança (TEE — Trusted Execution Environment)


## **17.4 Segurança e Atualização Contínua de Firmware (OTA Segura)**

Com a expansão dos sistemas embarcados conectados, **atualizações remotas** deixaram de ser conveniência para se tornarem obrigatórias. Sem suporte a OTA (Over-The-Air), qualquer dispositivo lançado no mercado torna-se um risco:

* falhas não podem ser corrigidas rapidamente
* vulnerabilidades conhecidas permanecem expostas
* produtos sofrem obsolescência prematura
* exigência de recall físico se torna provável

Ao mesmo tempo, atualizar firmware é um dos processos **mais críticos** em um sistema embarcado — é aqui que dispositivos podem ser inutilizados.

Por isso, o conceito moderno é **OTA segura**.

---

### **17.4.1 O Pipeline de Segurança em Firmware Moderno**

A segurança em sistemas embarcados segue uma cadeia lógica:

#### **1. Boot Seguro (Secure Boot)**

Impede inicialização de firmware não autorizado.
O hardware valida a assinatura digital da imagem antes de executá-la.

#### **2. Verificação de Integridade (Integrity Check)**

Mesmo depois de carregado, firmware e arquivos críticos têm suas assinaturas verificadas (SHA, RSA, ECC).

#### **3. Atualização Segura (Secure OTA)**

O novo firmware só é aceito se:

* vier assinado por chave confiável
* o pacote de atualização for íntegro
* o dispositivo estiver em estado consistente para aplicar o update

#### **4. Execução em Ambiente Isolado**

Aqui surgem TrustZone, TEE, hypervisors e partições dedicadas.

#### **5. Rotinas de Recuperação (Fail-Safe)**

Um dispositivo sempre deve poder restaurar sua versão anterior se a atualização falhar.

---

### **17.4.2 Estruturas de Partições para OTA Confiável**

A forma mais comum de garantir OTA robusta é o modelo **A/B**:

* partição “A” → versão atual
* partição “B” → versão nova

O dispositivo aplica o update na partição inativa.
Após reiniciar:

* se a partição é válida → trânsito normal
* se falhar → rollback automático

Sistemas como Android, ChromeOS e gateways industriais já usam esse padrão há anos.

Para dispositivos menores (MCUs), um bootloader customizado com:

* assinatura ECDSA
* fail-safe
* duplo slot de firmware

é suficiente.

---

### **17.4.3 Distribuição de Atualizações no Mundo Real**

Existem basicamente três padrões:

#### **1. Modelo “pull” (o dispositivo busca a atualização)**

Exemplo: IoT via MQTT, HTTPS, S3.
Vantagem: escalabilidade.

#### **2. Modelo “push” (servidor envia a atualização)**

Exemplo: redes industriais com controle centralizado.
Vantagem: controle absoluto.

#### **3. CDN distribuída (edge-aware OTA)**

Garante baixa latência e menor custo para milhões de dispositivos.

Independentemente do método, **sem criptografia e assinatura digital não é OTA — é suicídio de segurança**.

---

### **17.4.4 Desafios Modernos**

* Dispositivos com conectividade instável podem destruir o próprio firmware.
* Falhas na cadeia de certificados tornam milhões de equipamentos vulneráveis.
* Uma atualização mal testada pode paralisar uma fábrica.
* Regras de compliance (IEC 62443, NIST) são cada vez mais rígidas.

Por isso, equipes embarcadas evoluíram para incluir:

* DevOps embarcado
* pipelines com teste em hardware-in-the-loop
* validação remota progressiva (canary deploy)

---

## **17.5 Computação Embarcada e IA de Borda (TinyML)**

Chegamos a uma das fronteiras mais dinâmicas do embarcado moderno.

Durante anos, inteligência artificial dependia de servidores potentes.
Hoje, microcontroladores de poucos dólares executam:

* classificação de áudio
* detecção de anomalias
* reconhecimento de gestos
* controle preditivo
* compressão inteligente de sinais

Tudo isso **sem enviar dados para a nuvem**.

Isso é TinyML — *Machine Learning extremamente otimizado* para hardware limitado.

---

### **17.5.1 Por que IA na Borda?**

#### **1. Latência**

Um servodrive não pode esperar 120 ms de ida e volta para cloud.

#### **2. Privacidade**

Enviar áudio ou vídeo bruto para servidores externos pode ser ilegal.

#### **3. Custo Operacional**

Cloud é cara.
Milhões de inferências por dia custam muito mais do que um microcontrolador de US$ 5.

#### **4. Resiliência**

Sistemas industriais e agrícolas dependem de robustez offline.

---

### **17.5.2 A Stack Tecnológica do TinyML**

Hoje, o fluxo típico envolve:

1. **Treinamento offline** (TensorFlow, PyTorch)
2. **Conversão de modelo** (TensorFlow Lite Micro, ONNX simplificado)
3. **Quantização extrema**

   * INT8
   * INT4
   * até mesmo binária
4. **Execução em runtime mínimo**

   * TFLite Micro
   * CMSIS-NN
   * TVM micro
   * Edge Impulse runtimes

As redes são pequenas por design:

* CNNs rasas
* redes de convolução 1D
* decision trees otimizadas
* modelos híbridos com filtros digitais

---

### **17.5.3 O Futuro: IA + RTOS + Sensores**

O novo padrão em embarcados é:

* sensor
* preprocessamento local
* inferência leve
* decisão imediata
* envio para cloud somente do que é relevante

Alguns exemplos reais:

* microfones sempre ligados que detectam padrões específicos
* motores que antecipam falhas por vibração
* wearables que analisam sinais biológicos em tempo real
* drones que estabilizam voo usando redes neurais minúsculas

Neste cenário, o RTOS fornece o determinismo, enquanto a IA fornece eficiência e autonomia.

---

### **17.5.4 Limites Atuais**

Mesmo com modelos compactos, desafios persistem:

* falta de aceleração neural em muitos MCUs
* memória extremamente limitada (< 256 KB)
* dificuldade de treinar modelos compreensíveis e verificáveis
* testes de segurança e confiabilidade ainda imaturos

Por isso, TinyML é tanto uma tecnologia promissora quanto um campo em rápida evolução.

---

#### **Encerramento do Capítulo 17**

Este capítulo mostrou como o mundo embarcado moderno ultrapassa os limites tradicionais e incorpora tecnologias de ponta:

* **multicore e SMP** agora exigem engenharia de latência e determinismo
* **Linux embarcado** se tornou plataforma dominante em sistemas complexos
* **virtualização** habilita isolamento seguro e multipropósito
* **OTA segura** transforma dispositivos em produtos vivos
* **TinyML** leva inteligência para a borda, onde antes só havia firmware estático

O engenheiro embarcado do futuro não trabalha apenas com registradores e GPIO — ele navega em um ecossistema onde sistemas operacionais, segurança, computação distribuída e IA se encontram.

