# üìò **Cap√≠tulo 11 ‚Äî Gerenciamento de Energia**

## **11.1 Estados de Energia e Modos *Sleep***

Em sistemas embarcados, **energia √© um recurso t√£o cr√≠tico quanto tempo**.
Um dispositivo que funciona a bateria ‚Äî um sensor IoT, um smartwatch, ou mesmo um medidor inteligente ‚Äî n√£o ‚Äúexecuta c√≥digo o tempo todo‚Äù: ele alterna entre per√≠odos longos de inatividade e breves janelas de atividade intensa.

Essa oscila√ß√£o opera sobre um conjunto de **modos de energia**, oferecidos pelo hardware do microcontrolador:

---

### **11.1.1 Modos t√≠picos de energia (exemplo: ARM Cortex-M)**

| Modo             | Clock da CPU | Mem√≥ria          | Perif√©ricos | Corrente t√≠pica |
| ---------------- | ------------ | ---------------- | ----------- | --------------- |
| **Run**          | ligado       | ligado           | ligados     | 5‚Äì20 mA         |
| **Sleep / Idle** | *interrupto* | ligado           | ligados     | 1‚Äì3 mA          |
| **Deep Sleep**   | desligado    | ligado           | parciais    | 50‚Äì300 ¬µA       |
| **Standby**      | off          | reten√ß√£o parcial | m√≠nimos     | 1‚Äì20 ¬µA         |
| **Shutdown**     | off          | off              | off         | ~100 nA         |

O programador seleciona o modo desejado acionando instru√ß√µes dedicadas da CPU, como:

* **WFI** ‚Äî *Wait For Interrupt*
* **WFE** ‚Äî *Wait For Event*

Essas instru√ß√µes colocam o n√∫cleo em espera sem que o programador precise ‚Äúcongelar‚Äù o restante do sistema manualmente.

---

### **11.1.2 Exemplo (Cortex-M): entrando em sleep com WFI**

```c
#include "stm32f4xx.h"

void enter_sleep_mode(void) {
    // Habilita o modo Sleep no System Control Register
    SCB->SCR &= ~(1 << 2);  // SLEEPDEEP = 0 ‚Üí modo Sleep normal

    // Suspende a CPU at√© a pr√≥xima interrup√ß√£o
    __WFI();
}
```

O microcontrolador continua gerando clocks para perif√©ricos (como UART ou SPI), mas a CPU fica parada, consumindo quase nada at√© receber um evento externo (um timer, uma GPIO, um DMA, etc.).

---

### **11.1.3 Deep Sleep: desligando clock principal**

```c
void enter_deep_sleep(void) {
    SCB->SCR |= (1 << 2);   // SLEEPDEEP = 1

    // Configura os perif√©ricos permitidos a acordar (exemplo: RTC)
    PWR->CSR |= PWR_CSR_EWUP;   // Wake-Up pin habilitado

    __WFI();  // ou __WFE();
}
```

Nesta configura√ß√£o, o clock principal do sistema (HSI/HSE/PLL) √© desligado, deixando apenas:

* RTC
* Timers de baixa frequ√™ncia
* GPIOs configuradas como wake-up sources
* Mem√≥ria SRAM em reten√ß√£o

---

### **11.1.4 A filosofia do design: ‚ÄúFa√ßa menos, durma mais‚Äù**

Um bom projeto de energia em embarcados **maximiza o tempo em que o processador dorme**.
O objetivo n√£o √© ‚Äúrodar eficiente‚Äù. O objetivo √© **rodar pouco**.

O programador estruturado (Tanenbaum aproveitaria para enfatizar isso) faz o sistema reagir a eventos:

* interrup√ß√£o de timer
* recep√ß√£o de pacote
* leitura de sensor conclu√≠da
* fronteira de comunica√ß√£o
* bot√£o pressionado

E n√£o em *polling*.

---

## **11.2 Clock Gating e Power Gating**

Se entrar em *sleep* √© desligar a **CPU**, clock/power gating √© desligar **o resto**.

No n√≠vel do sil√≠cio, um SoC possui diversos dom√≠nios energ√©ticos ‚Äî blocos independentes:

* CPU
* barramento
* GPIO
* ADC
* SPI/I¬≤C/UART
* temporizadores
* mem√≥ria SRAM
* PLLs e fontes de clock

O objetivo √© **n√£o alimentar aquilo que n√£o est√° sendo usado**.

---

### **11.2.1 Clock Gating ‚Äî desligando o clock de perif√©ricos**

√â o mecanismo mais comum:
se um perif√©rico n√£o recebe clock ‚Üí n√£o executa l√≥gica interna ‚Üí n√£o consome energia din√¢mica.

Exemplo (STM32, pseudo real):

```c
void disable_unused_peripherals(void) {
    RCC->APB1ENR &= ~(RCC_APB1ENR_SPI2EN   |
                      RCC_APB1ENR_USART3EN |
                      RCC_APB1ENR_I2C1EN);
}
```

O clock gating √© normalmente controlado pelo **RCC** (Reset and Clock Control).

**Cen√°rio t√≠pico:**
Um sensor √© lido a cada 5 segundos via SPI ‚Üí n√£o deixe o SPI ligado durante todo esse intervalo.

---

### **11.2.2 Power Gating ‚Äî desligando blocos inteiros**

O power gating √© mais dr√°stico:
ele literalmente **corta a alimenta√ß√£o** do dom√≠nio e perde o estado interno.

Isso s√≥ est√° dispon√≠vel em microcontroladores mais avan√ßados (por exemplo, STM32L4, ESP32 ou SoCs Linux embarcado).

Exemplo conceitual (pseudo C):

```c
void power_off_analog_block(void) {
    PWR->CR |= PWR_CR_ALS_OFF; // bit fict√≠cio
}
```

Usa-se power gating para:

* r√°dio (BLE/Wi-Fi) quando n√£o em uso
* m√≥dulos de criptografia
* sensores anal√≥gicos integrados
* segunda CPU (dual-core, como ESP32)

---

### **11.2.3 Rela√ß√£o entre clock gating e modos sleep**

Geralmente:

* **Sleep leve** ‚Üí s√≥ a CPU dorme
* **Deep Sleep** ‚Üí clock gating mais agressivo
* **Standby** ‚Üí power gating em dom√≠nios inteiros

---

## **11.3 Wake-Up Sources (Fontes de Despertar)**

De nada adianta dormir se n√£o pudermos acordar.
Um microcontrolador em deep sleep pode acordar por:

#### **Fontes comuns de wake-up**

* **RTC / timer de baixa frequ√™ncia**
  (para leituras peri√≥dicas)
* **Interrup√ß√µes externas (EXTI)**
  bot√µes, detec√ß√£o de movimento, sinal de r√°dio
* **Eventos de comunica√ß√£o**
  UART receive, CAN bus activity
* **DMA conclu√≠do**
* **Watchdog Timer (√†s vezes)**
* **Perif√©ricos always-on**
  como comparadores anal√≥gicos ou sensores ‚Äúultra low power‚Äù

---

#### **Exemplo: acordando com RTC (Cortex-M)**

```c
void configure_rtc_wakeup(void) {
    // Configura o RTC para gerar um evento a cada 1 s
    RTC->WUTR = 32768 - 1;  // prescaler para 1 Hz
    RTC->CR |= RTC_CR_WUTE;
}

void enter_deep_sleep_rtc(void) {
    SCB->SCR |= (1 << 2);   // SLEEPDEEP

    // Habilitar fonte RTC como wakeup
    EXTI->IMR |= EXTI_IMR_MR20;

    __WFI();
}
```

Esse √© um padr√£o cl√°ssico:
um sistema dorme profundamente e acorda periodicamente para:

* coletar dados
* transmitir pacotes
* atualizar rel√≥gios
* fazer housekeeping

E volta a dormir.

---

#### **Exemplo: acordando por GPIO**

```c
void gpio_as_wakeup_pin(void) {
    EXTI->IMR  |= EXTI_IMR_MR0;    // habilita GPIO0 como wakeup
    EXTI->RTSR |= EXTI_RTSR_TR0;   // rising edge
}
```

Isso √© √∫til para:

* bot√µes
* reed switches
* sensores PIR
* ‚Äúinterruptores digitais‚Äù

---

#### **Exemplo: acordando via comunica√ß√£o (UART)**

UART idle line detection ‚Üí evento de wakeup.

Em plataformas como o ESP32 ou MSP430, a UART pode funcionar em modo ‚Äúlow power listener‚Äù.

Pseudo C (n√£o execut√°vel, mas realista):

```c
void uart_low_power_wakeup(void) {
    UART->CR3 |= UART_CR3_WUFIE;   // habilita wake-up por RX
    __WFI();
}
```

Quando o primeiro byte chega ‚Üí interrup√ß√£o ‚Üí CPU acorda ‚Üí troca para clock principal ‚Üí processa.

---

#### **O ciclo cl√°ssico de energia**

1. A CPU completa a tarefa
2. Configura a fonte de wake-up
3. Desliga clocks/perif√©ricos
4. Executa WFI
5. Acorda por evento
6. Restaura clock e perif√©ricos
7. Retoma fluxo normal

Essa estrutura aparece **em todos os sistemas embarcados eficientes**, do Arduino ao ESP32, de wearables a sensores industriais.


## **11.4 Pol√≠ticas de Economia Energ√©tica em RTOS**

Um sistema bare-metal geralmente delega ao programador a tarefa de dizer explicitamente quando dormir.
J√° um **RTOS** ‚Äî como FreeRTOS, Zephyr, ThreadX ‚Äî tenta fazer isso automaticamente, transformando per√≠odos ociosos em oportunidades para economizar energia.

A ideia √© simples:

> ‚ÄúSe nada precisa ser feito agora, a CPU deve dormir at√© o pr√≥ximo evento relevante.‚Äù

Mas implementar isso √© surpreendentemente dif√≠cil ‚Äî exige que o sistema operacional *entenda o futuro* (ou ao menos um peda√ßo dele).

---

### **11.4.1 O papel da tarefa Idle**

Todo RTOS possui uma **tarefa idle** com prioridade m√≠nima.
Ela roda sempre que nenhuma outra tarefa est√° pronta.

Em sistemas comuns (Windows, Linux), a tarefa idle roda loops como:

```c
while (1) {
    // mede temperatura, coleta estat√≠sticas, etc.
}
```

Mas em sistemas embarcados, ela deve ser o oposto:

```c
while (1) {
    __WFI();   // dormir at√© pr√≥xima interrup√ß√£o
}
```

Isso faz com que o RTOS automaticamente coloque o MCU em modo Sleep *sempre* que n√£o houver tarefas prontas.

---

### **11.4.2 Tick Timer: o maior vil√£o da energia**

Em muitos RTOS, o escalonador desperta periodicamente por meio de um ‚Äútick‚Äù ‚Äî normalmente a cada 1 ms.

Esse **tick peri√≥dico impede que o sistema durma profundamente**.

Imagine:

* CPU dorme
* tick de 1 ms ‚Üí acorda
* CPU vai dormir de novo
* tick ‚Üí acorda

Resultado: consumo maior que o necess√°rio.

---

### **11.4.3 Tickless Idle ‚Äî o ‚Äúpulo do gato‚Äù**

Para resolver isso, surgiu o **tickless idle**:

> O sistema desliga o tick peri√≥dico sempre que sabe que n√£o h√° tarefas prontas para os pr√≥ximos N milissegundos.

Tanenbaum diria que isso √© an√°logo a um kernel que, em vez de fazer ‚Äúpolling‚Äù, usa alarmes programados.

#### Funcionamento:

1. RTOS calcula o tempo at√© o pr√≥ximo evento (timer de tarefa, timeout de sem√°foro, etc.).
2. Programa o hardware para acordar somente neste momento.
3. Entra em deep sleep.
4. No despertar, reconstr√≥i quantos ‚Äúticks virtuais‚Äù se passaram.

Esses sistemas podem reduzir o consumo em **ordens de grandeza**.

---

### **11.4.4 Exemplo: habilitando tickless no FreeRTOS**

```c
// Em FreeRTOSConfig.h:
#define configUSE_TICKLESS_IDLE 1
```

E pronto ‚Äî a CPU deixa de acordar em intervalos fixos.

Um exemplo ilustrativo de economia:
um sistema que dorme por 500 ms entre leituras de sensores pode reduzir consumo de 3 mA para 100 ¬µA.

---

### **11.4.5 Idle Hook e Static Power Management**

Quase todo RTOS permite que o usu√°rio escreva fun√ß√µes chamadas durante o idle:

```c
void vApplicationIdleHook(void) {
    // Podemos desligar perif√©ricos aqui
    if (!peripheral_in_use) {
        disable_adc();
    }

    __WFI();
}
```

O RTOS chama o hook, e o hook chama o *sleep* real.
Assim o controle fica parcialmente no kernel, parcialmente na aplica√ß√£o.

---

### **11.4.6 Escalonamento orientado a energia**

Sistemas cr√≠ticos (IoT industrial, wearables, automotivo) empregam estrat√©gias mais complexas:

* **deferimento de tarefas**
  ‚ÄúAguarde 20 ms para agrupar opera√ß√µes e evitar wakeups desnecess√°rios.‚Äù

* **coalesc√™ncia de interrup√ß√µes**
  Agrupa eventos de rede ou DMA para reduzir entradas/sa√≠das de deep sleep.

* **limita√ß√£o de frequ√™ncia din√¢mica (DVFS)**
  ‚ÄúExecute mais devagar quando a tarefa n√£o √© urgente.‚Äù

Isso torna o RTOS n√£o apenas ‚Äúgestor de tempo‚Äù, mas ‚Äúgestor de energia‚Äù.

---

## **11.5 Medi√ß√£o e Otimiza√ß√£o do Consumo**

√â imposs√≠vel otimizar aquilo que voc√™ n√£o mede ‚Äî √© uma das grandes m√°ximas de engenharia.

Em embarcados, medir energia envolve entender:

* consumo est√°tico (fugas de transistores)
* consumo din√¢mico (comuta√ß√£o de gate)
* consumo por wakeups excessivos
* custo de ligar e desligar um perif√©rico

Tanenbaum diria que isso √© como medir a efici√™ncia de um sistema operacional,
mas com mult√≠metros e oscilosc√≥pios em vez de benchmarks.

---

### **11.5.1 Instrumentos usados na pr√°tica**

#### **1. Mult√≠metro de precis√£o**

Para consumo m√©dio em modo sleep/deep sleep.

#### **2. Fonte de alimenta√ß√£o program√°vel**

Para registrar curvas de corrente.

#### **3. Oscilosc√≥pio + resistor de shunt**

Permite observar picos de consumo de microsegundos ‚Äî quando o radio liga, quando o PLL trava, etc.

#### **4. Medidores especializados**

Exemplos modernos:

* Otii Arc
* Nordic Power Profiler Kit II
* Joulescope JS110

Essas ferramentas mostram **gr√°ficos de corrente vs. tempo** de alt√≠ssima precis√£o.

---

### **11.5.2 Medindo consumo com resistor shunt**

Coloca-se um resistor de baixa resist√™ncia (ex: 1 Œ©) em s√©rie com o dispositivo:

```
VDD ‚îÄ‚îÄ/\/\/‚îÄ‚îÄ MCU
        R
```

A corrente √© deduzida por:

```
I = V / R
```

Exemplo: se o oscilosc√≥pio mede 10 mV ‚Üí
I = 10 mA.

Essa t√©cnica √© indispens√°vel para observar spikes de 1 ¬µs que um mult√≠metro jamais captaria.

---

### **11.5.3 T√©cnicas cl√°ssicas de otimiza√ß√£o**

#### **(1) Reduzir frequ√™ncia (DVFS simples)**

Menos Hz = menos toggling = menos energia.

```c
RCC->CFGR |= RCC_CFGR_HPRE_DIV4;   // divide clock por 4
```

#### **(2) Desligar perif√©ricos ociosos**

```c
RCC->APB1ENR &= ~RCC_APB1ENR_I2C1EN;
```

#### **(3) Executar tarefas em rajadas curtas**

Melhor fazer tudo de uma vez e voltar ao deep sleep.

#### **(4) Usar DMA**

DMA consome menos que CPU fazendo c√≥pias.

```c
DMA1_Stream0->CR |= DMA_SxCR_EN;
```

#### **(5) Minimizar interrup√ß√µes**

* agrupar timers
* agrupar transmiss√µes
* usar buffers grandes

Wakeups custam energia.

#### **(6) Otimizar c√≥digo cr√≠tico (√†s vezes em assembly)**

Exemplo (pseudocode ARM): loop r√°pido sem acessos desnecess√°rios √† mem√≥ria:

```asm
loop:
    LDR r0, [r1], #4
    ADD r2, r2, r0
    SUBS r3, r3, #1
    BNE loop
```

Menos instru√ß√µes ‚Üí CPU termina mais r√°pido ‚Üí volta ao *sleep*.

---

### **11.5.4 Estrat√©gia geral de engenharia**

Um bom engenheiro embarcado segue o ciclo:

```
medir ‚Üí analisar ‚Üí otimizar ‚Üí medir novamente
```

Nunca se otimiza no escuro.





